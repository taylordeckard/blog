<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Distributed Dashboard: Creating a Networked Client to Power Centralized Insights | Taylor's Blog</title><meta name=keywords content="distributed systems,javascript,programming,rust,websockets"><meta name=description content="This post details an experiment that consists of creating a client application that connects to a centralized server and provides data updates on request."><meta name=author content="Taylor Deckard"><link rel=canonical href=https://www.taylordeckard.me/blog/posts/distributed-dashboard/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/blog/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.taylordeckard.me/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.taylordeckard.me/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.taylordeckard.me/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://www.taylordeckard.me/blog/apple-touch-icon.png><link rel=mask-icon href=https://www.taylordeckard.me/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Distributed Dashboard: Creating a Networked Client to Power Centralized Insights"><meta property="og:description" content="This post details an experiment that consists of creating a client application that connects to a centralized server and provides data updates on request."><meta property="og:type" content="article"><meta property="og:url" content="https://www.taylordeckard.me/blog/posts/distributed-dashboard/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-11T00:00:00+00:00"><meta property="article:modified_time" content="2024-11-11T00:00:00+00:00"><meta property="og:site_name" content="Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Distributed Dashboard: Creating a Networked Client to Power Centralized Insights"><meta name=twitter:description content="This post details an experiment that consists of creating a client application that connects to a centralized server and provides data updates on request."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://www.taylordeckard.me/blog/posts/"},{"@type":"ListItem","position":3,"name":"Distributed Dashboard: Creating a Networked Client to Power Centralized Insights","item":"https://www.taylordeckard.me/blog/posts/distributed-dashboard/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Distributed Dashboard: Creating a Networked Client to Power Centralized Insights","name":"Distributed Dashboard: Creating a Networked Client to Power Centralized Insights","description":"This post details an experiment that consists of creating a client application that connects to a centralized server and provides data updates on request.","keywords":["distributed systems","javascript","programming","rust","websockets"],"articleBody":"I have been wanting to try a project in rust for a few years now, and a few days ago, I finally started. My idea seemed simple. I wanted to create a “hub” service that can be connected to from an arbitrary number clients. Once clients are connected, a viewer can make a request to the hub and quickly pull data from any of the connected clients. Here is a diagram of how I envisioned it:\nsequenceDiagram actor Viewer participant Hub Client A-\u003e\u003eHub: Connects via WebSocket Viewer-\u003e\u003eHub: Request data from Client A Hub-\u003e\u003eClient A: Notifies via WebSocket that request is pending Client A-\u003e\u003eHub: Responds with Data Hub-\u003e\u003eViewer: Responds with Data This design allows for disparate data to be accessed from a central location.\nIf you’d like a preview, I have deployed the code to my website. A client IP addressed should be listed. If you click it, the browser will initiate the request detailed in the above diagram. The returned dataset is the last 40 minutes of CPU utilization metrics for the client program host machine.\nThe Hub A single hub program keeps track of and facilitates communication to the network of clients. It does this using warp. Warp is web server framework in rust that allows for simultaneous websocket and http endpoints. Its configuration looks like this:\n// This stores info for each WebSocket client pub type Users = Arc\u003cRwLock\u003cHashMap\u003cusize, Client\u003e\u003e\u003e; // The browser hits this route to retrieve data from a specific Client ID let proxy_route = warp::path!(\"api\" / \"proxy\" / String) .and(warp::get()) .and(users.clone()) .and_then(proxy::handler); // The Client posts its data to this route let response_route = warp::path!(\"api\" / \"proxy\" / \"response\" / String) .and(warp::post()) .and(warp::body::bytes()) .and_then(client_response_handler); // This route lists all of the clients currently connected to the hub let clients_route = warp::path!(\"api\" / \"clients\") .and(warp::get()) .and(users.clone()) .and_then(clients::handler); // This is the WebSocket server route let ws_route = warp::path!(\"ws\") .and(warp::ws()) .and(warp::addr::remote()) .and(users.clone()) .map(|ws: warp::ws::Ws, addr: Option\u003cSocketAddr\u003e, users| { ws.on_upgrade(move |socket| user_connected(socket, addr, users)) }); // Serve files from the \"public\" directory let static_route = warp::fs::dir(\"public\").with(log); // Define all of the routes let routes = proxy_route .or(clients_route) .or(response_route) .or(ws_route) .or(static_route) .recover(handle_rejection); // Bind the server with graceful shutdown let (addr, server_future) = warp::serve(routes).bind_with_graceful_shutdown( (host, config.http_server.port), shutdown_signal(running.clone()), ); The first route handler takes a String as path parameter (i.e the browser sends a GET request to /api/proxy/{some_client_id}). The function handler for these requests looks like this:\npub async fn handler(source: String, users: Users) -\u003e Result\u003cimpl warp::Reply, warp::Rejection\u003e { let id: usize = source .parse() .map_err(|_e| warp::reject::custom(ParseError))?; let user_map = users.read().await; let user = user_map.get(\u0026id); if let Some(user) = user { let body = ClientMessage { request_id: Uuid::new_v4().to_string(), }; let mut req_map = PENDING_REQUESTS.write().await; req_map.insert(body.request_id.clone(), None); drop(req_map); let msg = Message::text(serde_json::to_string(\u0026body).unwrap()); if let Err(_disconnected) = user.sender.send(msg) { eprintln!(\"Could not reach client through websocket.\"); }; let response = poll_for_response(\u0026body.request_id).await; let json_res: Value = serde_json::from_str(\u0026response.unwrap()).expect(\"Expected response to be valid JSON\"); Ok(warp::reply::json(\u0026json_res)) } else { Err(warp::reject::not_found()) } } This performs the following steps:\nReads the path parameter source and converts it to unsigned integer. Attempts to find the client with an id matching the supplied parameter. If a client is found, a WebSocket message is sent to the client along with a generated uuid. Waits for a client to post a response with the same uuid. Responds with the data from the client. The route handler for step 4 looks like this:\npub async fn client_response_handler( request_id: String, body: warp::hyper::body::Bytes, ) -\u003e Result\u003cimpl warp::Reply, warp::Rejection\u003e { let data = std::str::from_utf8(\u0026body).unwrap(); let mut req_map = PENDING_REQUESTS.write().await; if req_map.get(\u0026request_id).is_none() { eprintln!(\"here\"); drop(req_map); return Err(warp::reject::custom(RequestIdNotFound)); } req_map.insert(request_id, Some(data.to_string())); Ok(warp::reply::html(\"Success\")) } The data from the post body is written to a hashmap where the key is the generated uuid for the request. The poll_for_response method simply checks for a non-null value in HashMap where the key is the uuid and the value is the response from the client.\nCommand-Line Arguments In order to run the Hub and Client with the same binary, clap is used to parse CLI arguments.\nuse clap::{Parser, Subcommand}; /// Distributed Dashboard CLI #[derive(Parser)] #[command(version, about, long_about = None)] pub struct Args { #[command(subcommand)] pub command: Option\u003cCommands\u003e, } #[derive(Subcommand)] pub enum Commands { /// Runs the Client program Client {}, /// Runs the Hub program Hub {}, } The main function then runs different logic depending on the supplied argument, which looks like this:\nmatch \u0026args.command { Some(Commands::Client {}) =\u003e { println!(\"Running the Client program\"); ... } Some(Commands::Hub {}) =\u003e { println!(\"Running the Hub program\"); ... } None =\u003e { println!(\"Invalid subcommand. See usage.\"); } } The Client The client runs several threads in parallel.\nA WebSocket client that connects to the hub. A task that monitors CPU usage and records it in sqlite. A cleanup task that removes records from the sqlite database every day. To run these in parallel, tokio::spawn is used. Then, tokio::join waits for all to complete.\nlet cpu_task = tokio::spawn(cpu_monitor::cpu_monitoring_loop(running.clone())); let cleanup_task = tokio::spawn(cleanup::run(running.clone())); let websocket_task = tokio::spawn(websocket_client::connect_with_retry(running.clone())); let _ = tokio::join!(cpu_task, cleanup_task, websocket_task, ctrlc_task); Note: the ctrlc_task detects a user pressing ctrl-c on the keyboard so that all threads can be stopped gracefully.\nThe tokio-tungstenite crate is used for the WebSockets. Here is the portion that handles receiving messages from the hub and responding:\nMessage::Text(text) =\u003e { println!(\"Received: {text}\"); let result = from_str::\u003cReqMsg\u003e(\u0026text).unwrap(); let client = Client::new(); match get_all_stats() { Ok(response) =\u003e { let config = Options::new(); let server_url = format!( \"{}/{}\", config.hub.proxy_response_uri, result.request_id, ); let res = client .post(server_url) .json(\u0026response) .send() .await?; println!(\"{}\", res.text().await?); }, Err(_e) =\u003e { eprintln!(\"An error occurred\"); } } }, To monitor CPU usage, the sysinfo crate is used. This is super simple.\nlet mut sys = System::new_all(); sys.refresh_cpu_all(); let cpu_usage = sys.global_cpu_usage(); This value is written to sqlite every 5 seconds. The latest 500 rows of this data is sent to the hub when a WebSocket notification is received.\nAll of this code can be found on github. Remember, I am by no means rust expert yet, though I did learn a few things with this exercise.\nTry it yourself You can clone my repo and run the client to connect to my hub, assuming you have rust installed. First set some environment variables:\nexport HUB_PROXY_RESPONSE_URI=\"https://taylordeckard.me/distributed-dashboard/api/proxy/response\" export HUB_WS_URI=\"wss://taylordeckard.me/distributed-dashboard/ws\" Then compile and run the client.\ncargo run -- client After doing this, your client should show up (along with mine running in kubernetes) at https://taylordeckard.me/distributed-dashboard.\n","wordCount":"1052","inLanguage":"en","datePublished":"2024-11-11T00:00:00Z","dateModified":"2024-11-11T00:00:00Z","author":{"@type":"Person","name":"Taylor Deckard"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.taylordeckard.me/blog/posts/distributed-dashboard/"},"publisher":{"@type":"Organization","name":"Taylor's Blog","logo":{"@type":"ImageObject","url":"https://www.taylordeckard.me/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.taylordeckard.me/blog accesskey=h title="Blog (Alt + H)">Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.taylordeckard.me/blog/archives title=Archives><span>Archives</span></a></li><li><a href=https://www.taylordeckard.me/blog/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://www.taylordeckard.me/blog/tags title=Tags><span>Tags</span></a></li><li><a href=https://taylordeckard.me title=taylordeckard.me><span>taylordeckard.me</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.taylordeckard.me/blog>Home</a>&nbsp;»&nbsp;<a href=https://www.taylordeckard.me/blog/posts/>Posts</a></div><h1 class=post-title>Distributed Dashboard: Creating a Networked Client to Power Centralized Insights</h1><div class=post-description>This post details an experiment that consists of creating a client application that connects to a centralized server and provides data updates on request.</div><div class=post-meta><span title='2024-11-11 00:00:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Taylor Deckard&nbsp;|&nbsp;<a href=https://github.com/taylordeckard/blog/tree/main/content/posts/distributed-dashboard.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>I have been wanting to try a project in <a href=https://www.rust-lang.org/>rust</a> for a few years now, and a few days ago, I finally started. My idea seemed simple. I wanted to create a &ldquo;hub&rdquo; service that can be connected to from an arbitrary number clients. Once clients are connected, a viewer can make a request to the hub and quickly pull data from any of the connected clients. Here is a diagram of how I envisioned it:</p><pre class=mermaid>sequenceDiagram
    actor Viewer
    participant Hub
    Client A->>Hub: Connects via WebSocket
    Viewer->>Hub: Request data from Client A
    Hub->>Client A: Notifies via WebSocket that request is pending
    Client A->>Hub: Responds with Data
    Hub->>Viewer: Responds with Data
</pre><p>This design allows for disparate data to be accessed from a central location.</p><p>If you&rsquo;d like a preview, I have deployed the code to <a href=https://www.taylordeckard.me/distributed-dashboard>my website</a>. A client IP addressed should be listed. If you click it, the browser will initiate the request detailed in the above diagram. The returned dataset is the last 40 minutes of CPU utilization metrics for the client program host machine.</p><h2 id=the-hub>The Hub<a hidden class=anchor aria-hidden=true href=#the-hub>#</a></h2><p>A single hub program keeps track of and facilitates communication to the network of clients. It does this using <a href=https://github.com/seanmonstar/warp>warp</a>. Warp is web server framework in rust that allows for simultaneous websocket and http endpoints. Its configuration looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=w>    </span><span class=c1>// This stores info for each WebSocket client
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>type</span> <span class=nc>Users</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Arc</span><span class=o>&lt;</span><span class=n>RwLock</span><span class=o>&lt;</span><span class=n>HashMap</span><span class=o>&lt;</span><span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>Client</span><span class=o>&gt;&gt;&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// The browser hits this route to retrieve data from a specific Client ID
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>proxy_route</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>warp</span>::<span class=n>path</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;api&#34;</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=s>&#34;proxy&#34;</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=nb>String</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>and</span><span class=p>(</span><span class=n>warp</span>::<span class=n>get</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>and</span><span class=p>(</span><span class=n>users</span><span class=p>.</span><span class=n>clone</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>and_then</span><span class=p>(</span><span class=n>proxy</span>::<span class=n>handler</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// The Client posts its data to this route
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>response_route</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>warp</span>::<span class=n>path</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;api&#34;</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=s>&#34;proxy&#34;</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=s>&#34;response&#34;</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=nb>String</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>and</span><span class=p>(</span><span class=n>warp</span>::<span class=n>post</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>and</span><span class=p>(</span><span class=n>warp</span>::<span class=n>body</span>::<span class=n>bytes</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>and_then</span><span class=p>(</span><span class=n>client_response_handler</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// This route lists all of the clients currently connected to the hub
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>clients_route</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>warp</span>::<span class=n>path</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;api&#34;</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=s>&#34;clients&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>and</span><span class=p>(</span><span class=n>warp</span>::<span class=n>get</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>and</span><span class=p>(</span><span class=n>users</span><span class=p>.</span><span class=n>clone</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>and_then</span><span class=p>(</span><span class=n>clients</span>::<span class=n>handler</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// This is the WebSocket server route
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>ws_route</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>warp</span>::<span class=n>path</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;ws&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>and</span><span class=p>(</span><span class=n>warp</span>::<span class=n>ws</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>and</span><span class=p>(</span><span class=n>warp</span>::<span class=n>addr</span>::<span class=n>remote</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>and</span><span class=p>(</span><span class=n>users</span><span class=p>.</span><span class=n>clone</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>map</span><span class=p>(</span><span class=o>|</span><span class=n>ws</span>: <span class=nc>warp</span>::<span class=n>ws</span>::<span class=n>Ws</span><span class=p>,</span><span class=w> </span><span class=n>addr</span>: <span class=nb>Option</span><span class=o>&lt;</span><span class=n>SocketAddr</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>users</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>ws</span><span class=p>.</span><span class=n>on_upgrade</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>|</span><span class=n>socket</span><span class=o>|</span><span class=w> </span><span class=n>user_connected</span><span class=p>(</span><span class=n>socket</span><span class=p>,</span><span class=w> </span><span class=n>addr</span><span class=p>,</span><span class=w> </span><span class=n>users</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Serve files from the &#34;public&#34; directory
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>static_route</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>warp</span>::<span class=n>fs</span>::<span class=n>dir</span><span class=p>(</span><span class=s>&#34;public&#34;</span><span class=p>).</span><span class=n>with</span><span class=p>(</span><span class=n>log</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Define all of the routes
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>routes</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>proxy_route</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>or</span><span class=p>(</span><span class=n>clients_route</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>or</span><span class=p>(</span><span class=n>response_route</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>or</span><span class=p>(</span><span class=n>ws_route</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>or</span><span class=p>(</span><span class=n>static_route</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>recover</span><span class=p>(</span><span class=n>handle_rejection</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Bind the server with graceful shutdown
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>addr</span><span class=p>,</span><span class=w> </span><span class=n>server_future</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>warp</span>::<span class=n>serve</span><span class=p>(</span><span class=n>routes</span><span class=p>).</span><span class=n>bind_with_graceful_shutdown</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>(</span><span class=n>host</span><span class=p>,</span><span class=w> </span><span class=n>config</span><span class=p>.</span><span class=n>http_server</span><span class=p>.</span><span class=n>port</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>shutdown_signal</span><span class=p>(</span><span class=n>running</span><span class=p>.</span><span class=n>clone</span><span class=p>()),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>The first route handler takes a String as path parameter (i.e the browser sends a GET request to <code>/api/proxy/{some_client_id}</code>). The function handler for these requests looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>async</span><span class=w> </span><span class=k>fn</span> <span class=nf>handler</span><span class=p>(</span><span class=n>source</span>: <span class=nb>String</span><span class=p>,</span><span class=w> </span><span class=n>users</span>: <span class=nc>Users</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=k>impl</span><span class=w> </span><span class=n>warp</span>::<span class=n>Reply</span><span class=p>,</span><span class=w> </span><span class=n>warp</span>::<span class=n>Rejection</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>id</span>: <span class=kt>usize</span> <span class=o>=</span><span class=w> </span><span class=n>source</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>parse</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>map_err</span><span class=p>(</span><span class=o>|</span><span class=n>_e</span><span class=o>|</span><span class=w> </span><span class=n>warp</span>::<span class=n>reject</span>::<span class=n>custom</span><span class=p>(</span><span class=n>ParseError</span><span class=p>))</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>user_map</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>users</span><span class=p>.</span><span class=n>read</span><span class=p>().</span><span class=k>await</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>user</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>user_map</span><span class=p>.</span><span class=n>get</span><span class=p>(</span><span class=o>&amp;</span><span class=n>id</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>user</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>user</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>body</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ClientMessage</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>request_id</span>: <span class=nc>Uuid</span>::<span class=n>new_v4</span><span class=p>().</span><span class=n>to_string</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>req_map</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>PENDING_REQUESTS</span><span class=p>.</span><span class=n>write</span><span class=p>().</span><span class=k>await</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>req_map</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>body</span><span class=p>.</span><span class=n>request_id</span><span class=p>.</span><span class=n>clone</span><span class=p>(),</span><span class=w> </span><span class=nb>None</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>drop</span><span class=p>(</span><span class=n>req_map</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>msg</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Message</span>::<span class=n>text</span><span class=p>(</span><span class=n>serde_json</span>::<span class=n>to_string</span><span class=p>(</span><span class=o>&amp;</span><span class=n>body</span><span class=p>).</span><span class=n>unwrap</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=n>_disconnected</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>user</span><span class=p>.</span><span class=n>sender</span><span class=p>.</span><span class=n>send</span><span class=p>(</span><span class=n>msg</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=fm>eprintln!</span><span class=p>(</span><span class=s>&#34;Could not reach client through websocket.&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>response</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>poll_for_response</span><span class=p>(</span><span class=o>&amp;</span><span class=n>body</span><span class=p>.</span><span class=n>request_id</span><span class=p>).</span><span class=k>await</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>json_res</span>: <span class=nc>Value</span><span class=w> </span><span class=o>=</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>serde_json</span>::<span class=n>from_str</span><span class=p>(</span><span class=o>&amp;</span><span class=n>response</span><span class=p>.</span><span class=n>unwrap</span><span class=p>()).</span><span class=n>expect</span><span class=p>(</span><span class=s>&#34;Expected response to be valid JSON&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>Ok</span><span class=p>(</span><span class=n>warp</span>::<span class=n>reply</span>::<span class=n>json</span><span class=p>(</span><span class=o>&amp;</span><span class=n>json_res</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>Err</span><span class=p>(</span><span class=n>warp</span>::<span class=n>reject</span>::<span class=n>not_found</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>This performs the following steps:</p><ol><li>Reads the path parameter <code>source</code> and converts it to unsigned integer.</li><li>Attempts to find the client with an id matching the supplied parameter.</li><li>If a client is found, a WebSocket message is sent to the client along with a generated uuid.</li><li>Waits for a client to post a response with the same uuid.</li><li>Responds with the data from the client.</li></ol><p>The route handler for step 4 looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>async</span><span class=w> </span><span class=k>fn</span> <span class=nf>client_response_handler</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>request_id</span>: <span class=nb>String</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>body</span>: <span class=nc>warp</span>::<span class=n>hyper</span>::<span class=n>body</span>::<span class=n>Bytes</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=k>impl</span><span class=w> </span><span class=n>warp</span>::<span class=n>Reply</span><span class=p>,</span><span class=w> </span><span class=n>warp</span>::<span class=n>Rejection</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>data</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>std</span>::<span class=kt>str</span>::<span class=n>from_utf8</span><span class=p>(</span><span class=o>&amp;</span><span class=n>body</span><span class=p>).</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>req_map</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>PENDING_REQUESTS</span><span class=p>.</span><span class=n>write</span><span class=p>().</span><span class=k>await</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>req_map</span><span class=p>.</span><span class=n>get</span><span class=p>(</span><span class=o>&amp;</span><span class=n>request_id</span><span class=p>).</span><span class=n>is_none</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>eprintln!</span><span class=p>(</span><span class=s>&#34;here&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>drop</span><span class=p>(</span><span class=n>req_map</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=n>warp</span>::<span class=n>reject</span>::<span class=n>custom</span><span class=p>(</span><span class=n>RequestIdNotFound</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>req_map</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>request_id</span><span class=p>,</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>data</span><span class=p>.</span><span class=n>to_string</span><span class=p>()));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>Ok</span><span class=p>(</span><span class=n>warp</span>::<span class=n>reply</span>::<span class=n>html</span><span class=p>(</span><span class=s>&#34;Success&#34;</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>The data from the post body is written to a hashmap where the key is the generated uuid for the request. The <code>poll_for_response</code> method simply checks for a non-null value in HashMap where the key is the uuid and the value is the response from the client.</p><h2 id=command-line-arguments>Command-Line Arguments<a hidden class=anchor aria-hidden=true href=#command-line-arguments>#</a></h2><p>In order to run the Hub and Client with the same binary, <a href=https://github.com/clap-rs/clap>clap</a> is used to parse CLI arguments.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>clap</span>::<span class=p>{</span><span class=n>Parser</span><span class=p>,</span><span class=w> </span><span class=n>Subcommand</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=sd>/// Distributed Dashboard CLI
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=cp>#[derive(Parser)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[command(version, about, long_about = None)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Args</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[command(subcommand)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>command</span>: <span class=nb>Option</span><span class=o>&lt;</span><span class=n>Commands</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[derive(Subcommand)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>enum</span> <span class=nc>Commands</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Runs the Client program
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=n>Client</span><span class=w> </span><span class=p>{},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Runs the Hub program
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=n>Hub</span><span class=w> </span><span class=p>{},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>The main function then runs different logic depending on the supplied argument, which looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>match</span><span class=w> </span><span class=o>&amp;</span><span class=n>args</span><span class=p>.</span><span class=n>command</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>Some</span><span class=p>(</span><span class=n>Commands</span>::<span class=n>Client</span><span class=w> </span><span class=p>{})</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Running the Client program&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>Some</span><span class=p>(</span><span class=n>Commands</span>::<span class=n>Hub</span><span class=w> </span><span class=p>{})</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Running the Hub program&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>None</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Invalid subcommand. See usage.&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=the-client>The Client<a hidden class=anchor aria-hidden=true href=#the-client>#</a></h2><p>The client runs several threads in parallel.</p><ol><li>A WebSocket client that connects to the hub.</li><li>A task that monitors CPU usage and records it in sqlite.</li><li>A cleanup task that removes records from the sqlite database every day.</li></ol><p>To run these in parallel, <code>tokio::spawn</code> is used. Then, <code>tokio::join</code> waits for all to complete.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>cpu_task</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tokio</span>::<span class=n>spawn</span><span class=p>(</span><span class=n>cpu_monitor</span>::<span class=n>cpu_monitoring_loop</span><span class=p>(</span><span class=n>running</span><span class=p>.</span><span class=n>clone</span><span class=p>()));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>cleanup_task</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tokio</span>::<span class=n>spawn</span><span class=p>(</span><span class=n>cleanup</span>::<span class=n>run</span><span class=p>(</span><span class=n>running</span><span class=p>.</span><span class=n>clone</span><span class=p>()));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>websocket_task</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tokio</span>::<span class=n>spawn</span><span class=p>(</span><span class=n>websocket_client</span>::<span class=n>connect_with_retry</span><span class=p>(</span><span class=n>running</span><span class=p>.</span><span class=n>clone</span><span class=p>()));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tokio</span>::<span class=n>join</span><span class=o>!</span><span class=p>(</span><span class=n>cpu_task</span><span class=p>,</span><span class=w> </span><span class=n>cleanup_task</span><span class=p>,</span><span class=w> </span><span class=n>websocket_task</span><span class=p>,</span><span class=w> </span><span class=n>ctrlc_task</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>Note: the ctrlc_task detects a user pressing ctrl-c on the keyboard so that all threads can be stopped gracefully.</p><p>The <a href=https://github.com/snapview/tokio-tungstenite>tokio-tungstenite</a> crate is used for the WebSockets. Here is the portion that handles receiving messages from the hub and responding:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>Message</span>::<span class=n>Text</span><span class=p>(</span><span class=n>text</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Received: {text}&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>let</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>from_str</span>::<span class=o>&lt;</span><span class=n>ReqMsg</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>text</span><span class=p>).</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>let</span><span class=w> </span><span class=n>client</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Client</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>match</span><span class=w> </span><span class=n>get_all_stats</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nb>Ok</span><span class=p>(</span><span class=n>response</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=kd>let</span><span class=w> </span><span class=n>config</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Options</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=kd>let</span><span class=w> </span><span class=n>server_url</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>format!</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=s>&#34;{}/{}&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=n>config</span><span class=p>.</span><span class=n>hub</span><span class=p>.</span><span class=n>proxy_response_uri</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=n>result</span><span class=p>.</span><span class=n>request_id</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=kd>let</span><span class=w> </span><span class=n>res</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>client</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=p>.</span><span class=n>post</span><span class=p>(</span><span class=n>server_url</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=p>.</span><span class=n>json</span><span class=p>(</span><span class=o>&amp;</span><span class=n>response</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=p>.</span><span class=n>send</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=p>.</span><span class=k>await</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>res</span><span class=p>.</span><span class=n>text</span><span class=p>().</span><span class=k>await</span><span class=o>?</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nb>Err</span><span class=p>(</span><span class=n>_e</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=fm>eprintln!</span><span class=p>(</span><span class=s>&#34;An error occurred&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>},</span><span class=w>
</span></span></span></code></pre></div><p>To monitor CPU usage, the <a href=https://github.com/GuillaumeGomez/sysinfo>sysinfo</a> crate is used. This is super simple.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>sys</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>System</span>::<span class=n>new_all</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>sys</span><span class=p>.</span><span class=n>refresh_cpu_all</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>cpu_usage</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>sys</span><span class=p>.</span><span class=n>global_cpu_usage</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><p>This value is written to sqlite every 5 seconds. The latest 500 rows of this data is sent to the hub when a WebSocket notification is received.</p><p>All of this code can be found <a href=https://github.com/taylordeckard/distributed_dashboard>on github</a>. Remember, I am by no means rust expert yet, though I did learn a few things with this exercise.</p><h3 id=try-it-yourself>Try it yourself<a hidden class=anchor aria-hidden=true href=#try-it-yourself>#</a></h3><p>You can clone my repo and run the client to connect to my hub, assuming you have rust installed. First set some environment variables:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nb>export</span> <span class=nv>HUB_PROXY_RESPONSE_URI</span><span class=o>=</span><span class=s2>&#34;https://taylordeckard.me/distributed-dashboard/api/proxy/response&#34;</span>
</span></span><span class=line><span class=cl><span class=nb>export</span> <span class=nv>HUB_WS_URI</span><span class=o>=</span><span class=s2>&#34;wss://taylordeckard.me/distributed-dashboard/ws&#34;</span>
</span></span></code></pre></div><p>Then compile and run the client.</p><pre tabindex=0><code>cargo run -- client
</code></pre><p>After doing this, your client should show up (along with mine running in kubernetes) at <a href=https://taylordeckard.me/distributed-dashboard>https://taylordeckard.me/distributed-dashboard</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.taylordeckard.me/blog/tags/distributed-systems/>distributed systems</a></li><li><a href=https://www.taylordeckard.me/blog/tags/javascript/>javascript</a></li><li><a href=https://www.taylordeckard.me/blog/tags/programming/>programming</a></li><li><a href=https://www.taylordeckard.me/blog/tags/rust/>rust</a></li><li><a href=https://www.taylordeckard.me/blog/tags/websockets/>websockets</a></li></ul><nav class=paginav><a class=next href=https://www.taylordeckard.me/blog/posts/bourbon/><span class=title>Next »</span><br><span>Bourbon Search pt. 1: Scraper</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></script><script type=module>
		import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
		mermaid.initialize({ startOnLoad: true });
	  </script></body></html>