<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Creating a Vim Plugin to Edit Parquet Files | Taylor's Blog</title>
<meta name=keywords content="programming,rust,vim,spark,iceberg"><meta name=description content="For the past several years, my work has focused on data engineering and developing tools that simplify data processing. One of the most common file formats I work with is Parquet, a columnar storage file format that is optimized for use with big data processing frameworks like Apache Spark and Apache IcebergFor the past several years, my work has focused on data engineering and developing tools that simplify data processing.."><meta name=author content="Taylor Deckard"><link rel=canonical href=https://www.taylordeckard.me/blog/posts/parquet/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://www.taylordeckard.me/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.taylordeckard.me/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.taylordeckard.me/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://www.taylordeckard.me/blog/apple-touch-icon.png><link rel=mask-icon href=https://www.taylordeckard.me/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.taylordeckard.me/blog/posts/parquet/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://www.taylordeckard.me/blog/posts/parquet/"><meta property="og:site_name" content="Taylor's Blog"><meta property="og:title" content="Creating a Vim Plugin to Edit Parquet Files"><meta property="og:description" content="For the past several years, my work has focused on data engineering and developing tools that simplify data processing. One of the most common file formats I work with is Parquet, a columnar storage file format that is optimized for use with big data processing frameworks like Apache Spark and Apache IcebergFor the past several years, my work has focused on data engineering and developing tools that simplify data processing.."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-04T00:00:00+00:00"><meta property="article:modified_time" content="2025-05-04T00:00:00+00:00"><meta property="article:tag" content="Programming"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Vim"><meta property="article:tag" content="Spark"><meta property="article:tag" content="Iceberg"><meta name=twitter:card content="summary"><meta name=twitter:title content="Creating a Vim Plugin to Edit Parquet Files"><meta name=twitter:description content="For the past several years, my work has focused on data engineering and developing tools that simplify data processing. One of the most common file formats I work with is Parquet, a columnar storage file format that is optimized for use with big data processing frameworks like Apache Spark and Apache IcebergFor the past several years, my work has focused on data engineering and developing tools that simplify data processing.."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.taylordeckard.me/blog/posts/"},{"@type":"ListItem","position":2,"name":"Creating a Vim Plugin to Edit Parquet Files","item":"https://www.taylordeckard.me/blog/posts/parquet/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Creating a Vim Plugin to Edit Parquet Files","name":"Creating a Vim Plugin to Edit Parquet Files","description":"For the past several years, my work has focused on data engineering and developing tools that simplify data processing. One of the most common file formats I work with is Parquet, a columnar storage file format that is optimized for use with big data processing frameworks like Apache Spark and Apache IcebergFor the past several years, my work has focused on data engineering and developing tools that simplify data processing..","keywords":["programming","rust","vim","spark","iceberg"],"articleBody":"For the past several years, my work has focused on data engineering and developing tools that simplify data processing. One of the most common file formats I work with is Parquet, a columnar storage file format that is optimized for use with big data processing frameworks like Apache Spark and Apache IcebergFor the past several years, my work has focused on data engineering and developing tools that simplify data processing..\nIn my most recent project, I have worked on building end-to-end testing capabilities for data pipelines. To do this, input data is generated and stored in Parquet files within the GitHub repository. After the data has been sent through a pipeline, another ‚Äúexpected output‚Äù Parquet file is compared against the actual output.\nFor anyone unfamiliar, Parquet files are binary (not human-readable,) which makes it difficult to inspect the contents of these files or to make quick edits. While there are tools available to convert Parquet files to CSV or JSON for easier inspection, I wanted to create a Vim plugin that would allow me to view and edit Parquet files directly within Vim.\nThe Idea With Vimscript, it is possible to run code during certain events. For example, when a file is opened, you can run a function to check the file type and load the appropriate syntax highlighting. Similarly, there is another hook that allows you to run code when a file is written.\nSo, using these hooks I can convert a parquet file to some easier to edit format (I chose JSONL) when the file is opened, and then convert it back to Parquet when the file is saved.\nStarting with Vimscript The Vimscript for this plugin is relatively simple.\nViewing Parquet Files Here is the part that handles viewing the contents of a Parquet file:\nfunction! ParquetView(filepath) let tmpfile = tempname() . \".vimparq.jsonl\" let cmd = \"vimparq view \" . shellescape(a:filepath) . \" \u003e \" . shellescape(tmpfile) call system(cmd) silent! execute 'edit ' . tmpfile setlocal filetype=json setlocal nowrap setlocal syntax=off let b:parquet_original = a:filepath let b:parquet_tmpfile = tmpfile endfunction When the ParquetView function is invoked with a file path (filepath), it generates a unique temporary filename with a .vimparq.jsonl extension. It then constructs and runs a shell command using an external tool (vimparq view, more on this in a bit) to convert the given Parquet file to JSONL format, redirecting the output to the temporary file. After the command completes, the function opens the resulting JSONL file in the current Vim buffer, sets the filetype to JSON, disables line wrapping, and disables syntax highlighting for better performance or cleaner viewing. Finally, it stores the original Parquet file path and the temporary JSONL path in buffer-local variables (b:parquet_original and b:parquet_tmpfile) for later use, such as saving changes back to the Parquet format.\nThe hook that calls this function is BufReadPost. This is a Vim event that is triggered after a buffer has been read. The following code registers the ParquetView function to this event:\nautocmd BufReadPost *.parquet call ParquetView(expand(\"%:p\")) This line sets up an autocommand that listens for the BufReadPost event specifically for files with the .parquet extension. When such a file is opened, it calls the ParquetView function, passing the full path of the file being opened (expand(\"%:p\")) as an argument.\nOne more thing to note: the temporary file has a .vimparq.jsonl extension for good reason. This is important because it allows us to differentiate between the temporary JSONL file and any other JSONL files that might be opened in Vim.\nEditing Parquet Files Now for the saving part. The BufWriteCmd event is triggered just before a buffer is written to a file. This is where we will convert the JSONL file back to Parquet format:\nfunction! ParquetSave(filepath) if exists(\"b:parquet_tmpfile\") \u0026\u0026 exists(\"b:parquet_original\") echom \"üõ† ParquetSave triggered\" \" Save buffer contents to the temp file write! let cmd = \"vimparq edit \" . shellescape(b:parquet_original) . \" \" . shellescape(b:parquet_tmpfile) let output = system(cmd) echom \"Updated Parquet: \" . b:parquet_original \" Optionally clean up call delete(b:parquet_tmpfile) \" Reload original .parquet if needed else echom \"No edit buffer associated!\" endif endfunction This function checks if the buffer-local variables b:parquet_tmpfile and b:parquet_original exist. If they do, it writes the current buffer contents to the temporary JSONL file, constructs a command to convert the JSONL back to Parquet format using the external tool (vimparq edit), and executes that command. After the conversion, it cleans up by deleting the temporary JSONL file. If the buffer-local variables do not exist, it outputs a message indicating that no associated temporary edit buffer was found.\nAgain, this function is registered to the appropriate event:\nautocmd BufWriteCmd *.vimparq.jsonl call ParquetSave(expand(\"%:p\")) Creating Parquets from Scratch So far, we‚Äôve only converted existing Parquet files to JSONL and back. But what if you want to create a new Parquet file from scratch? This is also possible with one more function:\nfunction! ParquetCreate(filepath) \" Called when a new *.parquet file is opened let tmpfile = tempname() . \".vimparq.jsonl\" silent! execute 'edit ' . tmpfile setlocal filetype=json setlocal nowrap setlocal syntax=off let b:parquet_original = a:filepath let b:parquet_tmpfile = tmpfile endfunction This function is similar to the ParquetView function, but it does not run the external command. Instead, it creates a new temporary JSONL file and opens it in Vim for editing. The user can then write JSONL data directly into this buffer. When they save the buffer, the ParquetSave function will be called to convert the JSONL data into a Parquet file.\nWhat is vimparq? Aside from being the name of the repository, ‚Äúvimparq‚Äù is also the name I have given to the command-line tool that handles the conversion between Parquet and JSONL formats. The Vim plugin itself is just a wrapper around this tool, which is written in Rust.\nWriting the Parquet Converter CLI I wrote a very simple Rust program with Clap and arrow. Clap is a framework for command-line argument parsing, and Arrow is a Rust implementation of the Apache Arrow columnar data format, which is the underlying format for Parquet files.\nHere is the code for the view command:\nuse std::fs::File; use std::path::PathBuf; use arrow::record_batch::RecordBatch; use arrow::json::LineDelimitedWriter; use parquet::arrow::arrow_reader::ParquetRecordBatchReaderBuilder; pub fn view_parquet(path: \u0026PathBuf) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e { let file = File::open(path)?; let builder = ParquetRecordBatchReaderBuilder::try_new(file)?; let reader = builder.build()?; let batches: Vec\u003cRecordBatch\u003e = reader.collect::\u003cstd::result::Result\u003c_, _\u003e\u003e()?; write_json_lines(\u0026batches) } fn write_json_lines(batches: \u0026[RecordBatch]) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e { // Lock stdout (or use any Write impl‚ÄîFile, Vec, etc.) let stdout = std::io::stdout(); let mut handle = stdout.lock(); // Create a JSON-Lines writer over that handle let mut writer = LineDelimitedWriter::new(\u0026mut handle); // Write each RecordBatch // The write_batches method takes \u0026[\u0026RecordBatch] let batch_refs: Vec\u003c\u0026RecordBatch\u003e = batches.iter().collect(); writer.write_batches(\u0026batch_refs)?; // Finish to flush any buffered output writer.finish()?; Ok(()) } Given a Parquet file path, this function opens the file, reads it into a vector of RecordBatch objects, and then writes each batch in JSONL format using the LineDelimitedWriter. The write_json_lines function handles the actual writing of the JSONL data to standard output.\nThe Vim plugin will load this output into a buffer for viewing and editing.\nThe view command is just one of the commands in the vimparq tool. There is also a edit command that takes a JSONL file and writes it back to Parquet format. Arguments supplied to this command are the path to the JSONL file and the path to the output Parquet file.\nuse std::fs::File; use std::io::{BufReader, Seek, SeekFrom}; use std::path::PathBuf; use std::error::Error; use std::sync::Arc; use arrow::json::reader::{ReaderBuilder, infer_json_schema_from_seekable}; use parquet::arrow::ArrowWriter; pub fn edit_parquet(path: \u0026PathBuf, json_path: \u0026PathBuf) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e { // Open JSONL file let json_file = File::open(json_path)?; let mut buf_reader = BufReader::new(json_file); buf_reader.seek(SeekFrom::Start(0))?; // Infer schema let (schema, _) = infer_json_schema_from_seekable(\u0026mut buf_reader, Some(1))?; let schema = Arc::new(schema); // Read JSON using the schema let builder = ReaderBuilder::new(schema.clone()); let mut json_reader = builder.build(buf_reader)?; // Overwrite Parquet file let out_file = File::create(path)?; println!(\"Writing to: {:?}\", out_file); let mut writer = ArrowWriter::try_new(out_file, schema, None)?; while let Some(batch_result) = json_reader.next() { let batch = batch_result?; writer.write(\u0026batch)?; } writer.close()?; Ok(()) } This function opens the JSONL file, infers its schema, and then writes it to the specified Parquet file. The ArrowWriter is used to handle the writing of the data in Parquet format.\nWrapping Up This Vim plugin allows you to view and edit Parquet files directly within Vim, making it easier to inspect and modify data without needing to convert it to a different format first. The vimparq command-line tool handles the conversion between Parquet and JSONL formats, while the Vim plugin provides the editing experience. You can find all of the code for this project as well as installation instructions on GitHub.\n","wordCount":"1434","inLanguage":"en","datePublished":"2025-05-04T00:00:00Z","dateModified":"2025-05-04T00:00:00Z","author":{"@type":"Person","name":"Taylor Deckard"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.taylordeckard.me/blog/posts/parquet/"},"publisher":{"@type":"Organization","name":"Taylor's Blog","logo":{"@type":"ImageObject","url":"https://www.taylordeckard.me/blog/favicon.ico"}}}</script><link rel=stylesheet href=/blog/styles.css></link></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.taylordeckard.me/blog/ accesskey=h title="Blog (Alt + H)">Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.taylordeckard.me/blog/archives title=Archives><span>Archives</span></a></li><li><a href=https://www.taylordeckard.me/blog/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://www.taylordeckard.me/blog/tags title=Tags><span>Tags</span></a></li><li><a href=https://taylordeckard.me title=taylordeckard.me><span>taylordeckard.me</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.taylordeckard.me/blog/>Home</a>&nbsp;¬ª&nbsp;<a href=https://www.taylordeckard.me/blog/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Creating a Vim Plugin to Edit Parquet Files</h1><div class=post-meta><span title='2025-05-04 00:00:00 +0000 UTC'>May 4, 2025</span>&nbsp;¬∑&nbsp;7 min&nbsp;¬∑&nbsp;Taylor Deckard&nbsp;|&nbsp;<a href=https://github.com/taylordeckard/blog/tree/main/content/posts/parquet.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>For the past several years, my work has focused on data engineering and developing tools that simplify data processing. One of the most common file formats I work with is Parquet, a columnar storage file format that is optimized for use with big data processing frameworks like Apache Spark and Apache IcebergFor the past several years, my work has focused on data engineering and developing tools that simplify data processing..</p><p>In my most recent project, I have worked on building end-to-end testing capabilities for data pipelines. To do this, input data is generated and stored in Parquet files within the GitHub repository. After the data has been sent through a pipeline, another &ldquo;expected output&rdquo; Parquet file is compared against the actual output.</p><p>For anyone unfamiliar, Parquet files are binary (not human-readable,) which makes it difficult to inspect the contents of these files or to make quick edits. While there are tools available to convert Parquet files to CSV or JSON for easier inspection, I wanted to create a Vim plugin that would allow me to view and edit Parquet files directly within Vim.</p><h2 id=the-idea>The Idea<a hidden class=anchor aria-hidden=true href=#the-idea>#</a></h2><p>With Vimscript, it is possible to run code during certain events. For example, when a file is opened, you can run a function to check the file type and load the appropriate syntax highlighting. Similarly, there is another hook that allows you to run code when a file is written.</p><p>So, using these hooks I can convert a parquet file to some easier to edit format (I chose <a href=https://jsonlines.org/>JSONL</a>) when the file is opened, and then convert it back to Parquet when the file is saved.</p><h2 id=starting-with-vimscript>Starting with Vimscript<a hidden class=anchor aria-hidden=true href=#starting-with-vimscript>#</a></h2><p>The Vimscript for this plugin is relatively simple.</p><h3 id=viewing-parquet-files>Viewing Parquet Files<a hidden class=anchor aria-hidden=true href=#viewing-parquet-files>#</a></h3><p>Here is the part that handles viewing the contents of a Parquet file:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-vim data-lang=vim><span class=line><span class=cl><span class=k>function</span><span class=p>!</span> <span class=nx>ParquetView</span><span class=p>(</span><span class=nx>filepath</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=nx>tmpfile</span> <span class=p>=</span> <span class=nx>tempname</span><span class=p>()</span> . <span class=s2>&#34;.vimparq.jsonl&#34;</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=nx>cmd</span> <span class=p>=</span> <span class=s2>&#34;vimparq view &#34;</span> . <span class=nx>shellescape</span><span class=p>(</span><span class=nx>a</span>:<span class=nx>filepath</span><span class=p>)</span> . <span class=s2>&#34; &gt; &#34;</span> . <span class=nx>shellescape</span><span class=p>(</span><span class=nx>tmpfile</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>call</span> <span class=nx>system</span><span class=p>(</span><span class=nx>cmd</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>silent</span><span class=p>!</span> <span class=k>execute</span> <span class=s1>&#39;edit &#39;</span> . <span class=nx>tmpfile</span>
</span></span><span class=line><span class=cl>  <span class=nx>setlocal</span> <span class=k>filetype</span><span class=p>=</span><span class=nx>json</span>
</span></span><span class=line><span class=cl>  <span class=nx>setlocal</span> <span class=nx>nowrap</span>
</span></span><span class=line><span class=cl>  <span class=nx>setlocal</span> <span class=k>syntax</span><span class=p>=</span><span class=nx>off</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=nx>b</span>:<span class=nx>parquet_original</span> <span class=p>=</span> <span class=nx>a</span>:<span class=nx>filepath</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=nx>b</span>:<span class=nx>parquet_tmpfile</span> <span class=p>=</span> <span class=nx>tmpfile</span>
</span></span><span class=line><span class=cl><span class=k>endfunction</span>
</span></span></code></pre></div><p>When the <code>ParquetView</code> function is invoked with a file path (<code>filepath</code>), it generates a unique temporary filename with a <code>.vimparq.jsonl</code> extension. It then constructs and runs a shell command using an external tool (<code>vimparq view</code>, more on this in a bit) to convert the given Parquet file to JSONL format, redirecting the output to the temporary file. After the command completes, the function opens the resulting JSONL file in the current Vim buffer, sets the filetype to JSON, disables line wrapping, and disables syntax highlighting for better performance or cleaner viewing. Finally, it stores the original Parquet file path and the temporary JSONL path in buffer-local variables (<code>b:parquet_original</code> and <code>b:parquet_tmpfile</code>) for later use, such as saving changes back to the Parquet format.</p><p>The hook that calls this function is <code>BufReadPost</code>. This is a Vim event that is triggered after a buffer has been read. The following code registers the <code>ParquetView</code> function to this event:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-vim data-lang=vim><span class=line><span class=cl><span class=k>autocmd</span> <span class=nx>BufReadPost</span> *.<span class=nx>parquet</span> <span class=nx>call</span> <span class=nx>ParquetView</span><span class=p>(</span><span class=nx>expand</span><span class=p>(</span><span class=s2>&#34;%:p&#34;</span><span class=p>))</span>
</span></span></code></pre></div><p>This line sets up an autocommand that listens for the <code>BufReadPost</code> event specifically for files with the <code>.parquet</code> extension. When such a file is opened, it calls the <code>ParquetView</code> function, passing the full path of the file being opened (<code>expand("%:p")</code>) as an argument.</p><p>One more thing to note: the temporary file has a <code>.vimparq.jsonl</code> extension for good reason. This is important because it allows us to differentiate between the temporary JSONL file and any other JSONL files that might be opened in Vim.</p><h3 id=editing-parquet-files>Editing Parquet Files<a hidden class=anchor aria-hidden=true href=#editing-parquet-files>#</a></h3><p>Now for the saving part. The <code>BufWriteCmd</code> event is triggered just before a buffer is written to a file. This is where we will convert the JSONL file back to Parquet format:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-vim data-lang=vim><span class=line><span class=cl><span class=k>function</span><span class=p>!</span> <span class=nx>ParquetSave</span><span class=p>(</span><span class=nx>filepath</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=nx>exists</span><span class=p>(</span><span class=s2>&#34;b:parquet_tmpfile&#34;</span><span class=p>)</span> &amp;&amp; <span class=nx>exists</span><span class=p>(</span><span class=s2>&#34;b:parquet_original&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>echom</span> <span class=s2>&#34;üõ† ParquetSave triggered&#34;</span>
</span></span><span class=line><span class=cl><span class=c>    &#34; Save buffer contents to the temp file</span>
</span></span><span class=line><span class=cl>    <span class=nx>write</span><span class=p>!</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nx>cmd</span> <span class=p>=</span> <span class=s2>&#34;vimparq edit &#34;</span> . <span class=nx>shellescape</span><span class=p>(</span><span class=nx>b</span>:<span class=nx>parquet_original</span><span class=p>)</span> . <span class=s2>&#34; &#34;</span> . <span class=nx>shellescape</span><span class=p>(</span><span class=nx>b</span>:<span class=nx>parquet_tmpfile</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nx>output</span> <span class=p>=</span> <span class=nx>system</span><span class=p>(</span><span class=nx>cmd</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>echom</span> <span class=s2>&#34;Updated Parquet: &#34;</span> . <span class=nx>b</span>:<span class=nx>parquet_original</span>
</span></span><span class=line><span class=cl><span class=c>    &#34; Optionally clean up</span>
</span></span><span class=line><span class=cl>    <span class=nx>call</span> <span class=nx>delete</span><span class=p>(</span><span class=nx>b</span>:<span class=nx>parquet_tmpfile</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c>    &#34; Reload original .parquet if needed</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=nx>echom</span> <span class=s2>&#34;No edit buffer associated!&#34;</span>
</span></span><span class=line><span class=cl>  <span class=k>endif</span>
</span></span><span class=line><span class=cl><span class=k>endfunction</span>
</span></span></code></pre></div><p>This function checks if the buffer-local variables <code>b:parquet_tmpfile</code> and <code>b:parquet_original</code> exist. If they do, it writes the current buffer contents to the temporary JSONL file, constructs a command to convert the JSONL back to Parquet format using the external tool (<code>vimparq edit</code>), and executes that command. After the conversion, it cleans up by deleting the temporary JSONL file. If the buffer-local variables do not exist, it outputs a message indicating that no associated temporary edit buffer was found.</p><p>Again, this function is registered to the appropriate event:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-vim data-lang=vim><span class=line><span class=cl><span class=k>autocmd</span> <span class=nx>BufWriteCmd</span> *.<span class=nx>vimparq</span>.<span class=nx>jsonl</span> <span class=nx>call</span> <span class=nx>ParquetSave</span><span class=p>(</span><span class=nx>expand</span><span class=p>(</span><span class=s2>&#34;%:p&#34;</span><span class=p>))</span>
</span></span></code></pre></div><h3 id=creating-parquets-from-scratch>Creating Parquets from Scratch<a hidden class=anchor aria-hidden=true href=#creating-parquets-from-scratch>#</a></h3><p>So far, we&rsquo;ve only converted existing Parquet files to JSONL and back. But what if you want to create a new Parquet file from scratch? This is also possible with one more function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-vim data-lang=vim><span class=line><span class=cl><span class=k>function</span><span class=p>!</span> <span class=nx>ParquetCreate</span><span class=p>(</span><span class=nx>filepath</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c>  &#34; Called when a new *.parquet file is opened</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=nx>tmpfile</span> <span class=p>=</span> <span class=nx>tempname</span><span class=p>()</span> . <span class=s2>&#34;.vimparq.jsonl&#34;</span>
</span></span><span class=line><span class=cl>  <span class=nx>silent</span><span class=p>!</span> <span class=k>execute</span> <span class=s1>&#39;edit &#39;</span> . <span class=nx>tmpfile</span>
</span></span><span class=line><span class=cl>  <span class=nx>setlocal</span> <span class=k>filetype</span><span class=p>=</span><span class=nx>json</span>
</span></span><span class=line><span class=cl>  <span class=nx>setlocal</span> <span class=nx>nowrap</span>
</span></span><span class=line><span class=cl>  <span class=nx>setlocal</span> <span class=k>syntax</span><span class=p>=</span><span class=nx>off</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=nx>b</span>:<span class=nx>parquet_original</span> <span class=p>=</span> <span class=nx>a</span>:<span class=nx>filepath</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=nx>b</span>:<span class=nx>parquet_tmpfile</span> <span class=p>=</span> <span class=nx>tmpfile</span>
</span></span><span class=line><span class=cl><span class=k>endfunction</span>
</span></span></code></pre></div><p>This function is similar to the <code>ParquetView</code> function, but it does not run the external command. Instead, it creates a new temporary JSONL file and opens it in Vim for editing. The user can then write JSONL data directly into this buffer. When they save the buffer, the <code>ParquetSave</code> function will be called to convert the JSONL data into a Parquet file.</p><h3 id=what-is-vimparq>What is vimparq?<a hidden class=anchor aria-hidden=true href=#what-is-vimparq>#</a></h3><p>Aside from being the name of the repository, &ldquo;vimparq&rdquo; is also the name I have given to the command-line tool that handles the conversion between Parquet and JSONL formats. The Vim plugin itself is just a wrapper around this tool, which is written in Rust.</p><h2 id=writing-the-parquet-converter-cli>Writing the Parquet Converter CLI<a hidden class=anchor aria-hidden=true href=#writing-the-parquet-converter-cli>#</a></h2><p>I wrote a very simple Rust program with <a href=https://docs.rs/clap/latest/clap/>Clap</a> and <a href=https://arrow.apache.org/rust/arrow/index.html>arrow</a>. Clap is a framework for command-line argument parsing, and Arrow is a Rust implementation of the Apache Arrow columnar data format, which is the underlying format for Parquet files.</p><p>Here is the code for the <code>view</code> command:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>fs</span>::<span class=n>File</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>path</span>::<span class=n>PathBuf</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>arrow</span>::<span class=n>record_batch</span>::<span class=n>RecordBatch</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>arrow</span>::<span class=n>json</span>::<span class=n>LineDelimitedWriter</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>parquet</span>::<span class=n>arrow</span>::<span class=n>arrow_reader</span>::<span class=n>ParquetRecordBatchReaderBuilder</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>view_parquet</span><span class=p>(</span><span class=n>path</span>: <span class=kp>&amp;</span><span class=nc>PathBuf</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(),</span><span class=w> </span><span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=n>std</span>::<span class=n>error</span>::<span class=n>Error</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>file</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>File</span>::<span class=n>open</span><span class=p>(</span><span class=n>path</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>builder</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ParquetRecordBatchReaderBuilder</span>::<span class=n>try_new</span><span class=p>(</span><span class=n>file</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>reader</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>builder</span><span class=p>.</span><span class=n>build</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>batches</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>RecordBatch</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>reader</span><span class=p>.</span><span class=n>collect</span>::<span class=o>&lt;</span><span class=n>std</span>::<span class=n>result</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=n>_</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=o>&gt;&gt;</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>write_json_lines</span><span class=p>(</span><span class=o>&amp;</span><span class=n>batches</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>write_json_lines</span><span class=p>(</span><span class=n>batches</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=n>RecordBatch</span><span class=p>])</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(),</span><span class=w> </span><span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=n>std</span>::<span class=n>error</span>::<span class=n>Error</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Lock stdout (or use any Write impl‚ÄîFile, Vec&lt;u8&gt;, etc.)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>stdout</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>std</span>::<span class=n>io</span>::<span class=n>stdout</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>handle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>stdout</span><span class=p>.</span><span class=n>lock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Create a JSON-Lines writer over that handle
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>writer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>LineDelimitedWriter</span>::<span class=n>new</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>handle</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Write each RecordBatch
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// The write_batches method takes &amp;[&amp;RecordBatch]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>batch_refs</span>: <span class=nb>Vec</span><span class=o>&lt;&amp;</span><span class=n>RecordBatch</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>batches</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>collect</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>writer</span><span class=p>.</span><span class=n>write_batches</span><span class=p>(</span><span class=o>&amp;</span><span class=n>batch_refs</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Finish to flush any buffered output
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>writer</span><span class=p>.</span><span class=n>finish</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>Ok</span><span class=p>(())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Given a Parquet file path, this function opens the file, reads it into a vector of <code>RecordBatch</code> objects, and then writes each batch in JSONL format using the <code>LineDelimitedWriter</code>. The <code>write_json_lines</code> function handles the actual writing of the JSONL data to standard output.</p><p>The Vim plugin will load this output into a buffer for viewing and editing.</p><p>The <code>view</code> command is just one of the commands in the <code>vimparq</code> tool. There is also a <code>edit</code> command that takes a JSONL file and writes it back to Parquet format. Arguments supplied to this command are the path to the JSONL file and the path to the output Parquet file.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>fs</span>::<span class=n>File</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>io</span>::<span class=p>{</span><span class=n>BufReader</span><span class=p>,</span><span class=w> </span><span class=n>Seek</span><span class=p>,</span><span class=w> </span><span class=n>SeekFrom</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>path</span>::<span class=n>PathBuf</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>error</span>::<span class=n>Error</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>sync</span>::<span class=n>Arc</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>arrow</span>::<span class=n>json</span>::<span class=n>reader</span>::<span class=p>{</span><span class=n>ReaderBuilder</span><span class=p>,</span><span class=w> </span><span class=n>infer_json_schema_from_seekable</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>parquet</span>::<span class=n>arrow</span>::<span class=n>ArrowWriter</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>edit_parquet</span><span class=p>(</span><span class=n>path</span>: <span class=kp>&amp;</span><span class=nc>PathBuf</span><span class=p>,</span><span class=w> </span><span class=n>json_path</span>: <span class=kp>&amp;</span><span class=nc>PathBuf</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>(),</span><span class=w> </span><span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=n>Error</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Open JSONL file
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>json_file</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>File</span>::<span class=n>open</span><span class=p>(</span><span class=n>json_path</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>buf_reader</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>BufReader</span>::<span class=n>new</span><span class=p>(</span><span class=n>json_file</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>buf_reader</span><span class=p>.</span><span class=n>seek</span><span class=p>(</span><span class=n>SeekFrom</span>::<span class=n>Start</span><span class=p>(</span><span class=mi>0</span><span class=p>))</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Infer schema
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>schema</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>infer_json_schema_from_seekable</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>buf_reader</span><span class=p>,</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=mi>1</span><span class=p>))</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>schema</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Arc</span>::<span class=n>new</span><span class=p>(</span><span class=n>schema</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Read JSON using the schema
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>builder</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ReaderBuilder</span>::<span class=n>new</span><span class=p>(</span><span class=n>schema</span><span class=p>.</span><span class=n>clone</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>json_reader</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>builder</span><span class=p>.</span><span class=n>build</span><span class=p>(</span><span class=n>buf_reader</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Overwrite Parquet file
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>out_file</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>File</span>::<span class=n>create</span><span class=p>(</span><span class=n>path</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Writing to: </span><span class=si>{:?}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>out_file</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>writer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ArrowWriter</span>::<span class=n>try_new</span><span class=p>(</span><span class=n>out_file</span><span class=p>,</span><span class=w> </span><span class=n>schema</span><span class=p>,</span><span class=w> </span><span class=nb>None</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>batch_result</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>json_reader</span><span class=p>.</span><span class=n>next</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>batch</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>batch_result</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>writer</span><span class=p>.</span><span class=n>write</span><span class=p>(</span><span class=o>&amp;</span><span class=n>batch</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>writer</span><span class=p>.</span><span class=n>close</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>Ok</span><span class=p>(())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>This function opens the JSONL file, infers its schema, and then writes it to the specified Parquet file. The <code>ArrowWriter</code> is used to handle the writing of the data in Parquet format.</p><h2 id=wrapping-up>Wrapping Up<a hidden class=anchor aria-hidden=true href=#wrapping-up>#</a></h2><p>This Vim plugin allows you to view and edit Parquet files directly within Vim, making it easier to inspect and modify data without needing to convert it to a different format first. The <code>vimparq</code> command-line tool handles the conversion between Parquet and JSONL formats, while the Vim plugin provides the editing experience. You can find all of the code for this project as well as installation instructions <a href=https://github.com/taylordeckard/vimparq>on GitHub</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.taylordeckard.me/blog/tags/programming/>Programming</a></li><li><a href=https://www.taylordeckard.me/blog/tags/rust/>Rust</a></li><li><a href=https://www.taylordeckard.me/blog/tags/vim/>Vim</a></li><li><a href=https://www.taylordeckard.me/blog/tags/spark/>Spark</a></li><li><a href=https://www.taylordeckard.me/blog/tags/iceberg/>Iceberg</a></li></ul><nav class=paginav><a class=next href=https://www.taylordeckard.me/blog/posts/irly/><span class=title>Next ¬ª</span><br><span>Creating a Website on a Hidden Network</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></script></body></html>