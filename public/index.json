[{"content":"A few months ago, our team was tasked with leading a new hire programming bootcamp. My focus has been creating course assignments for JavaScript, TypeScript, and Node.js. As a learning exercise, I created a CLI clone of the popular game Wordle to use as an example project.\nFor the bootcamp, I\u0026rsquo;ve broken down the project into various learning exercises. These exercises are assessed by unit test cases and linting jobs that run in Concourse CI. The tasks are fairly basic introductory material and (in my opinion) are less interesting than the overall functionality of the project.\nFor instance, in order to accurately clone the actual Wordle, I did a bit of reverse-engineering that turned out to be fairly simple. Inspecting the Wordle web page JavaScript source reveals that all of the answers for each day are stored in an array of strings. The answer for the current day is determined by using an index derived from the number of days since the first day of Wordle (June 19, 2021.)\nWith this information, I began coding a program that:\n Fetches the actual Wordle web page index.html file and parses it to get the JavaScript source file.  1 2 3  public static parseWordleIndex(html: string) { return html.match(/\u0026lt;script src=\u0026#34;(main.*?js)\u0026#34;\u0026gt;\u0026lt;\\/script\u0026gt;/)?.[1] ?? \u0026#39;\u0026#39;; }   Fetches the JavaScript file from step 1 and parses it to get the list of answers.  1 2 3 4 5 6 7 8  public static parseWordleJavascript(jsFile: string) { try { const array = jsFile.match(/;var ..=(\\[.*?\\])/)?.[1]; return JSON.parse(array ?? \u0026#39;[]\u0026#39;); } catch (e) { return []; } }   Finds the number of days since June 19, 2021 and uses that to get the current day\u0026rsquo;s answer. See the Pen Sample by Taylor Deckard (@taylordeckard) on CodePen.    From this point, all that is left is to write the CLI and game logic. I chose to use commander.js, which is a nice wrapper for argument parsing and command execution. Basic setup looks like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  import { program } from \u0026#39;commander\u0026#39;; import { commands } from \u0026#39;./commands\u0026#39;; program .name(\u0026#39;wordle\u0026#39;) .description(\u0026#39;A CLI Wordle clone\u0026#39;) .version(\u0026#39;1.0.0\u0026#39;); // Split commands out into separate modules to keep things tidy. // Add each command to the program here. commands.forEach((command) =\u0026gt; { let pgm = program .command(command.name) .description(command.description); if (command.options?.length) { command.options.forEach((opt) =\u0026gt; { pgm = pgm.option(opt.invocation, opt.description, opt.default); }); } pgm = pgm.action(command.action); }); program.parse(process.argv);   The game logic is pretty straight-forward. It give the user 6 chances to guess the correct word. After each guess, log green/yellow colors to indicate correctness.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  /** * Note: This is a snippet from a class method. The DataService * is a singleton used to retrieve and store remote data, * such as the Wordle answer list. */ const ds = DataService.instance; this._solution = (await ds.solution) ?? \u0026#39;\u0026#39;; // See next code snippet for the Prompter logic const prompter = new Prompter(); // MAX_ATTEMPTS is 6 for (let i = 0; i \u0026lt; MAX_ATTEMPTS; i += 1) { // Pass in the number of attempts remaining to inform the user  const { guess } = await prompter.promptUserGuess(MAX_ATTEMPTS - i); // Print results  new Guess(guess, this._solution) .markGreen() .markYellow() .logOutput(); if (guess === this._solution) { Logger.printf(YOU_WIN); this._solved = true; break; } } if (!this._solved) { Logger.printf(YOU_LOSE, this._solution); }   For prompting the user, I chose to use the inquirer.js module. It allows for input transformation and validation.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public async promptUserGuess(attemptsRemaining: number) { if (!this._acceptableGuesses) { const ds = DataService.instance; this._acceptableGuesses = await ds.wordlist; } return inquirer.prompt([ { message: `Guess a 5-letter word (${attemptsRemaining}attempts remaining):`, name: \u0026#39;guess\u0026#39;, transformer: (input: string) =\u0026gt; input.toLowerCase(), type: \u0026#39;input\u0026#39;, validate: Validator.checkGuess.bind(this, this._acceptableGuesses), }, ]); }   Finally, the logic for colorizing the guesses is:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  /** * Marks letters of the guess as green (correct) * * @returns {Guess} guess */ public markGreen() { // iterate over each letter of the guess  for (let i = 0; i \u0026lt; 5; i += 1) { const guessChar = this._guess[i]; const actualChar = this._solution[i]; // if the character in the guess matches the character at the  // same index of the solution, it should be marked green  if (guessChar === actualChar) { this._output[i] = Colorizer.green(guessChar); this._correctness[i] = Correctness.GREEN; this._remainingChars[i] = \u0026#39;\u0026#39;; } } return this; } /** * Marks letters of the guess as yellow (included in solution but wrong index) * * @returns {Guess} guess */ public markYellow() { // iterate over each letter of the guess  for (let i = 0; i \u0026lt; 5; i += 1) { const guessChar = this._guess[i]; /* if the character is included in the _remainingChars and does not match the current index of the solution, mark yellow note: _remainingChars is an array of characters of the solution that have not been marked green */ if (this._remainingChars.includes(guessChar) \u0026amp;\u0026amp; guessChar !== this._solution[i]) { this._correctness[i] = Correctness.YELLOW; this._output[i] = Colorizer.yellow(guessChar); } } return this; }   Now it\u0026rsquo;s done. The program can be executed with:\n1  npm start -- start   Later, I started working on another command that tries to solve the Wordle puzzle using an algorithm. For a start, I filtered the list of possible words based on previous guess outcomes. Then, I tested the algorithm against the list of wordle answers. I began tweaking the algorithm from there, doing things like trying different starting words or using strategies to eliminate letters.\nI was able adjust enough to achieve ~99.61% win accuracy. The automation can be run with:\n1  npm start -- solve   I\u0026rsquo;m sure the algorithm can be improved to reach 100%, though it\u0026rsquo;s a task for another time.\nCheck out the project on Github.\n","permalink":"https://www.taylordeckard.me/blog/posts/wordle/","summary":"A few months ago, our team was tasked with leading a new hire programming bootcamp. My focus has been creating course assignments for JavaScript, TypeScript, and Node.js. As a learning exercise, I created a CLI clone of the popular game Wordle to use as an example project.\nFor the bootcamp, I\u0026rsquo;ve broken down the project into various learning exercises. These exercises are assessed by unit test cases and linting jobs that run in Concourse CI.","title":"Wordle CLI with Node.js and TypeScript"},{"content":"I\u0026rsquo;ve been using Vim as my primary editor for ~7 years. When first starting to use it, I compared it to learning a musical instrument. When learning chord progressions I\u0026rsquo;d start by playing slowly at first, thinking for a bit about which fingers go on which positions. Similarly, I had to think for a few seconds about which keys to press for each edit I was about to make in Vim. As with an instrument, the number of times you repeat the sequences, the more fluid the motions become. After several weeks of coding in vim, I no longer had to pause.\nThe more I learned about things you can do with Vim, the more I wanted to use it\u0026hellip; and there is a lot you can do. For this post, I\u0026rsquo;ll go over how to get started using Vim from scratch.\nI spend a majority of my day in the macOS Terminal, which is one of the reasons I like using Vim so much. In order to start from a completely clean slate though, I\u0026rsquo;ll install vim fresh in a docker container running ubuntu linux. To do that in Terminal the command is:\n1  docker run -ti ubuntu   In the ubuntu shell, I\u0026rsquo;ll install vim with:\n1  apt-get update \u0026amp;\u0026amp; apt-get install -y vim   Then I\u0026rsquo;ll run Vim with vi. It looks like this: Now what? I\u0026rsquo;ll pretend for a moment that I have zero experience with Vim. The splash screen shown above gives a little context. Use :q\u0026lt;Enter\u0026gt;. Use :help\u0026lt;Enter\u0026gt; for on-line help. The Vim documentation is very good. You can also search for topics by using :help word\u0026lt;Enter\u0026gt; (where \u0026ldquo;word\u0026rdquo; is the topic you want to search for.)\nExecuting Commands First, note that typing : in normal mode (I\u0026rsquo;ll talk more about modes in a bit) will display the : at the bottom of the window. Any characters you type next will also be displayed here. This is the command-line input. Notice :help and :q are commands that do different things. There are many different commands. You can even run shell commands from Vim.\nFor now, just remember that :q!\u0026lt;Enter\u0026gt; quits Vim without saving. Notice I\u0026rsquo;ve added a !. This forces Vim to quit even if there are unsaved edits. Alternatively, :w\u0026lt;Enter\u0026gt; saves, and :wq!\u0026lt;Enter\u0026gt; quits and saves.\nMoving Around (part 1) Learning how to move the cursor around efficiently is probably one of the biggest challenges when starting out. The arrow keys can be used, but it is recommended to instead use h, j, k, and l. See the below mapping.\nUp: k Down: j Left: h Right: l Typing each of these keys individually will move one character for h or l and one line for j or k. If you want to move down 20 lines, you don\u0026rsquo;t have to press j 20 times. Instead, you can type 20j.\nWith that said, knowing which line to move down to can be difficult if you can\u0026rsquo;t see the line numbers. You can show them with :set number\u0026lt;Enter\u0026gt;. To make jumping around even easier, you can :set relativenumber\u0026lt;Enter\u0026gt; which will still display the line number of the current line, however all other lines display the number of lines away from the current line. See the example below.  .video-container { text-align: center; } .video-player { width: 600px; } @media screen and (max-width: 700px) { .video-player { width: 400px; } }  Sorry, your browser doesn't support embedded videos.   I like to have the relativenumber setting active every time I open a file. Luckily, there is an easy to make Vim remember all of your settings.\nConfiguring ~/.vimrc To store Vim configurations, I\u0026rsquo;ll create a .vimrc file.\n1  vi ~/.vimrc   Now I want to add the setting to show relative line numbers to the .vimrc file.\nset relativenumber There is a problem though. I haven\u0026rsquo;t mentioned how to insert text yet. To demonstrate, I\u0026rsquo;ll enter this key sequence: iset relativenumber\u0026lt;Esc\u0026gt;:wq!\u0026lt;Enter\u0026gt;. Now, to explain\u0026hellip;\nModes Vim has a few different editor modes that you can switch between:\n Normal: Cursor navigation, entering other modes. Command: Command execution mode. (Initiated with the : key from Normal mode) Insert: Text editing mode. Replace: Anything you type will replace the underlying text. Visual: Used to select text. There are also Visual Line and Visual Block modes which allow text selection in different ways.  Consider the key sequence iset relativenumber\u0026lt;Esc\u0026gt;:wq!\u0026lt;Enter\u0026gt;. Vim starts in Normal mode. The i key initiates Insert mode. At this point, set relativenumber is recorded as it is typed. Then, \u0026lt;Esc\u0026gt; exits Insert mode and Vim is back in Normal mode. Typing : enters Command mode and wq!\u0026lt;Enter\u0026gt; triggers the command to save and quit. When actively using Vim, I am switching between modes almost constantly.\nMapping Keys An awesome feature of Vim is the ability to map a key or key sequence to an action. This allows you customize Vim so that common tasks are easier to execute.\nFor instance, a mapping that I use is:\ninoremap jk \u0026lt;esc\u0026gt; This makes it so typing jk (quickly) in Insert mode will trigger the Escape keypress to enter Normal mode. I find this is easier than reaching to the Escape key for such a commonly performed action. There are very few scenarios when I actually need to insert the letters jk and on those occasions I can type slow so that the mapping isn\u0026rsquo;t triggered. You can add the above line to your ~/.vimrc to try it out.\nThe mapping might seem confusing at first. The first term, inoremap is the type of mapping. We can break this down further into three parts:\n i - denotes Insert mode nore - not recursive (other mappings cannot trigger this mapping) map - basic map command  The second term, jk, is the keypress sequence that triggers the mapping (input.) The third term, \u0026lt;esc\u0026gt;, is the key that the mapping executes (output.)\nAnother mapping that I use frequently is:\nnnoremap \u0026lt;C-n\u0026gt; :Explore\u0026lt;cr\u0026gt; Note the first term begins with a n which denotes the mapping will only trigger in Normal mode. The \u0026lt;C-n\u0026gt; represents a combined keypress of the Ctrl and n keys. The last term, :Explore\u0026lt;cr\u0026gt;, enters Command mode and executes netrw, the native Vim file explorer. (\u0026lt;cr\u0026gt; is \u0026ldquo;carriage return\u0026rdquo;, also known as the Enter key.)\nYou also have the option to make use of a \u0026ldquo;leader\u0026rdquo; key. This is a key of your choosing that you can use in mappings with the syntax: \u0026lt;leader\u0026gt;. I set my leader ket to be ; by adding the following line in my ~/.vimrc:\nlet mapleader = \u0026quot;;\u0026quot; Now, the leader can be used in mappings like this:\nnnoremap \u0026lt;leader\u0026gt;w :w!\u0026lt;cr\u0026gt; This mapping allows for quick saving with ;w in Normal mode.\nYou can also disable default mappings. In the past, to train myself to stop using the arrow keys for navigation, I added the following to my ~/.vimrc:\nnnoremap \u0026lt;Up\u0026gt; \u0026lt;nop\u0026gt; nnoremap \u0026lt;Down\u0026gt; \u0026lt;nop\u0026gt; nnoremap \u0026lt;Left\u0026gt; \u0026lt;nop\u0026gt; nnoremap \u0026lt;Right\u0026gt; \u0026lt;nop\u0026gt; vnoremap \u0026lt;Up\u0026gt; \u0026lt;nop\u0026gt; vnoremap \u0026lt;Down\u0026gt; \u0026lt;nop\u0026gt; vnoremap \u0026lt;Left\u0026gt; \u0026lt;nop\u0026gt; vnoremap \u0026lt;Right\u0026gt; \u0026lt;nop\u0026gt; inoremap \u0026lt;Up\u0026gt; \u0026lt;nop\u0026gt; inoremap \u0026lt;Down\u0026gt; \u0026lt;nop\u0026gt; inoremap \u0026lt;Left\u0026gt; \u0026lt;nop\u0026gt; inoremap \u0026lt;Right\u0026gt; \u0026lt;nop\u0026gt; This overrides the arrow keys to be no-ops in Normal, Visual, and Insert modes. With these set, you must use the h, j, k, and l keys instead.\nThere are many alternative ways to move the cursor around in Vim though\u0026hellip;\nMoving Around (part 2) When reading a large file, moving the cursor line by line is not ideal. Instead of using j/k to move, you can move half the page at a time with Ctrl-D/Ctrl-U.To go to the last line in the file, simply press G. To go back to the first line, press gg.  .video-container { text-align: center; } .video-player { width: 600px; } @media screen and (max-width: 700px) { .video-player { width: 400px; } }  Sorry, your browser doesn't support embedded videos.   On a long line, you may want to move forward and backward by word instead of by character. For this, use w to move to the next word and b to move to the previous. Similarly to moving down 20 lines with 20j, you can move forward 20 words with 20w.\nEntering ^ moves the cursor to the first non-whitespace character on a line and $ moves it to the last character.\nIf there is a particular character you need to reach on a line, f followed by the character will move the cursor to the next occurence of the character on the line. Using F will move to the previous occurence.\nYou can also easily perform a search to move your cursor to a word anywhere in the file. Simply type / (to search forward, ? to search backward) followed by the word you\u0026rsquo;re searching for, then Enter. When searching, n moves to the next occurence of the searched term, while N moves to the previous occurrence. Add the following line to your ~/.vimrc for Vim to highlight the search matches for you:\nset hlsearch Also, I like to use the following settings:\nset ignorecase set smartcase This makes it so searching for a word with all lowercase characters ignores case. However, a search including uppercase letters will be case-sensitive.  .video-container { text-align: center; } .video-player { width: 600px; } @media screen and (max-width: 700px) { .video-player { width: 400px; } }  Sorry, your browser doesn't support embedded videos.   When the cursor is placed on a character of a pair, like opening and closing brackets, % will move the cursor to the opposite character. For example, if you are editing a text file that looks like { \u0026quot;an\u0026quot;: \u0026quot;object\u0026quot; } and your cursor is on {, pressing % will move the cursor to }.\nIf at any time you make a bad move, you can go back to your previous position with Ctrl-o.\nEditing Text I\u0026rsquo;ve mentioned that the i key from Normal mode switches to Insert mode in which text is recorded as you type. There are other ways to enter Insert mode as well. All of the keys below will enter Insert mode and also move the cursor to a new position:\n a: Moves the cursor one character to the right. A: Moves the cursor to the end of the line. I: Moves the cursor to the beginning of the line. o: Inserts a line below the current line. O: Inserts a line above the current line.  Some keys enter Insert mode and also delete characters:\n c: Used in combination with a motion will delete characters within the motion. For instance, cw will delete the word all text from the cursor to the next word. cc: Deletes the entire line. C: Deletes all text on the line after the cursor. s: Deletes a single character.  Alternatively, some keys delete characters without changing from Normal mode:\n d: Works similarly to c except does not enter Insert mode. dd: Deletes the entire line (same as cc.) D: Deletes all text on the line after the cursor (C.) x: Deletes a single character.  If at any point you make a mistake, you can undo the action with u. (To redo the undo, use Ctrl-r.)\nSelecting Text Text selection is made possible in Vim with Visual mode. Ways to enter visual mode are:\n v: Selects a single character. V: Selects the entire line. Ctrl-v: Selects a single character, however subsequent cursor movement selects blocks of text vertically.  Moving the cursor after entering Visual mode will add to selection until exiting Visual mode with Escape or Ctrl-C.\nOnce in visual mode, you can perform actions on the selected text such as:\n d/x: Delete the selected text. c/s: Delete the selected text and enter Insert mode. gu/gU/~: Change the case of all letters in the selection. \u0026lt;/\u0026gt;: Indent the selected text left or right. :norm @\u0026lt;register\u0026gt;: Execute a macro on all lines (read about these a bit further down.) y: Yank (copy) the selected text.  Note that the above may not apply to Visual Block mode. Here\u0026rsquo;s an example of that:  .video-container { text-align: center; } .video-player { width: 600px; } @media screen and (max-width: 700px) { .video-player { width: 400px; } }  Sorry, your browser doesn't support embedded videos.   The above video shows how to convert a ordered list to an unordered list using Visual Block mode. The key sequence is \u0026lt;Ctrl-v\u0026gt;Gls-\u0026lt;Esc\u0026gt; Starting with the cursor in the top-left position, Ctrl-v enters Visual Block mode. Then, G moves the cursor to the bottom of the file, creating a selection of the entire first column. l moves the cursor to the right one character, expanding the selection to the first two columns. s then deletes the selected text and enters Insert mode. It is important to note that Insert mode from Visual Block affects all rows that were selected. This means that - inserts the dash and Esc exits Insert mode while inserting the \u0026ldquo;-\u0026rdquo; on all lines that were selected in the Visual Block.\nCopying and Pasting After selecting some text, you can yank (copy) it with y and then paste it with :\n p: Paste text immediately after the cursor. P: Paste text immediately before the cursor.  When yanked, text is stored in a register - a space in memory. Specifically, when yanked, text is stored in the default register (\u0026quot;).\nUsing a delete key (x, d, etc.) is actually similar to a \u0026ldquo;cut\u0026rdquo; in that some text is deleted and also stored in a register so that it can later be pasted.\nRegisters You can view the contents of a register by pressing Ctrl-r in Insert mode followed by the name of the register. You can try this out by selecting some text and typing yi\u0026lt;Ctrl-r\u0026gt;\u0026quot;. This output is the same as paste.\nYou can also yank and paste to a specified register. Select some text and type \u0026quot;ay. This yanks the selection to register a. Now, you can paste the contents of the a register with \u0026quot;ap. You could also use \u0026lt;Ctrl-r\u0026gt; to do the same, as described above. (In Insert mode, type \u0026lt;Ctrl-r\u0026gt;a.)\nMacros Macros are a useful feature that also make use of registers. They allow you to record a sequence of key presses and repeat the sequence any number of times.\nIn the below example, I use a macro to create an ordered list:  .video-container { text-align: center; } .video-player { width: 600px; } @media screen and (max-width: 700px) { .video-player { width: 400px; } }  Sorry, your browser doesn't support embedded videos.   First, i1.  is entered on the first line. Then, qa begins recording the macro. Any key pressed at this point will be recorded until q is pressed in Normal mode. ^ moves the cursor to the begining of the line. v enters visual mode and f  moves the cursor to the first space character. Then y yanks \u0026ldquo;1. \u0026quot; and moves the cursor back to the beginning of the line. j moves the cursor down. P pastes the \u0026ldquo;1. \u0026quot; before the cursor. ^ moves to the beginning of the 2nd line and \u0026lt;Ctrl-a\u0026gt; increments the number under the cursor by 1. Finally, q ends recording of the macro. The macro stored in the a register looks like this: ^vf yjP^\u0026lt;c-a\u0026gt;.\nTo use the macro, select the lines you want to execute the macro on and type :norm @a\u0026lt;Enter\u0026gt;. Another way to do this is to count the number of lines you need to apply the macro to and with the cursor on the first line in Normal mode type 7@a. (The number of lines is 7 for the example above.)\nIf you make a mistake when recording a macro, you can paste the register, correct the text, and then yank the fixed text back to the register. Then play the macro as you normally would.\nPlugins Check out VimAwesome for plugins. I personally use:\n ALE - Linting YouCompleteMe - Autocompletion incsearch.vim - Highlight text as you search vim-airline - Enhanced Status Bar vim-commentary - Mappings to add code comments vim-fugitive - Git Integration vim-surround - Mappings to easily delete, change and add parentheses, brackets, quotes, XML tags, and more surroundings in pairs.  For an example, I\u0026rsquo;ll install vim-airline using Vim\u0026rsquo;s native packages.\nFirst, I\u0026rsquo;ll need git:\napt install -y git Now, I\u0026rsquo;ll create a directory for the plugins:\nmkdir -p ~/.vim/pack/plugins/start Next, clone the vim-airline repository into the directory that was just created.\ngit clone https://github.com/vim-airline/vim-airline.git ~/.vim/pack/plugins/start/vim-airline Finally, add the following line to the ~/.vimrc to set the maximum number of colors that can be displayed by the host terminal:\nset t_Co=256 To check that the plugin is installed and working, restart Vim. It should now look like this: ","permalink":"https://www.taylordeckard.me/blog/posts/vim-1/","summary":"I\u0026rsquo;ve been using Vim as my primary editor for ~7 years. When first starting to use it, I compared it to learning a musical instrument. When learning chord progressions I\u0026rsquo;d start by playing slowly at first, thinking for a bit about which fingers go on which positions. Similarly, I had to think for a few seconds about which keys to press for each edit I was about to make in Vim.","title":"Vim Intro"},{"content":"I\u0026rsquo;ve started working on a proof-of-concept to improve query performance of a large dataset (5M+ rows.) The data is currently stored in a MySQL database.\nThe service is required to search, sort, filter, and paginate the data. Nowadays, these requirements are standard practice. However, with such a large dataset, some of the database queries are taking \u0026gt; 3 seconds, even with table partitioning.\nMy theory is that Elasticsearch will perform better than RDBMS for this use case. Only one way to find out\u0026hellip;\nRunning Elasticsearch Locally I already have Docker and docker-compose installed, so I just need to create a docker-compose config.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  version:\u0026#34;3.9\u0026#34;# Run 3 Elasticsearch containers simultaneously (es01, es02, es03)services:es01:image:docker.elastic.co/elasticsearch/elasticsearch:7.16.3container_name:es01environment:- node.name=es01- cluster.name=es-docker-cluster- discovery.seed_hosts=es02,es03- cluster.initial_master_nodes=es01,es02,es03- bootstrap.memory_lock=true- \u0026#34;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026#34;# Allow unlimited memory to be locked by this container processulimits:memlock:soft:-1hard:-1volumes:# Map data01 directory to container (for persistence)- data01:/usr/share/elasticsearch/dataports:# Map local port 9200 to container port 9200- 9200:9200networks:- elastices02:image:docker.elastic.co/elasticsearch/elasticsearch:7.16.3container_name:es02environment:- node.name=es02- cluster.name=es-docker-cluster- discovery.seed_hosts=es01,es03- cluster.initial_master_nodes=es01,es02,es03- bootstrap.memory_lock=true- \u0026#34;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026#34;ulimits:memlock:soft:-1hard:-1volumes:- data02:/usr/share/elasticsearch/datanetworks:- elastices03:image:docker.elastic.co/elasticsearch/elasticsearch:7.16.3container_name:es03environment:- node.name=es03- cluster.name=es-docker-cluster- discovery.seed_hosts=es01,es02- cluster.initial_master_nodes=es01,es02,es03- bootstrap.memory_lock=true- \u0026#34;ES_JAVA_OPTS=-Xms512m -Xmx512m\u0026#34;ulimits:memlock:soft:-1hard:-1volumes:- data03:/usr/share/elasticsearch/datanetworks:- elasticvolumes:data01:driver:localdata02:driver:localdata03:driver:local# ES Nodes run on a shared network that is bridged to the local machinenetworks:elastic:driver:bridge  Elasticsearch should be ready to go. Before running though, I\u0026rsquo;ll need to bump up Docker\u0026rsquo;s memory resources to \u0026gt; 4GB. Start docker-compose with\n1  docker-compose up   Creating an Index Now that Elasticsearch is running, it\u0026rsquo;s time to learn how to use it: REST API docs.\nFirst, I want to create an index (table in SQL) for my dataset so I can add documents (rows) to it.\nI create an index called assets (API Docs):\n1  curl -X PUT \u0026#39;http://localhost:9200/assets\u0026#39;   The following is shown in the docker-compose logs:\n1  {\u0026#34;type\u0026#34;: \u0026#34;server\u0026#34;, \u0026#34;timestamp\u0026#34;: \u0026#34;2022-01-21T15:50:11,935Z\u0026#34;, \u0026#34;level\u0026#34;: \u0026#34;INFO\u0026#34;, \u0026#34;component\u0026#34;: \u0026#34;o.e.c.m.MetadataCreateIndexService\u0026#34;, \u0026#34;cluster.name\u0026#34;: \u0026#34;es-docker-cluster\u0026#34;, \u0026#34;node.name\u0026#34;: \u0026#34;es02\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;[assets] creating index, cause [api], templates [], shards [1]/[1]\u0026#34;, \u0026#34;cluster.uuid\u0026#34;: \u0026#34;6BFPOn84Q8qFIfS2FSmsBw\u0026#34;, \u0026#34;node.id\u0026#34;: \u0026#34;Sm9PsrFzTu6tkK0tAt0qvw\u0026#34; }   which indicates the index creation was successful.\nAnother way to check that the index creation was successful is to do\n1  curl --head \u0026#39;http://localhost:9200/assets\u0026#39;   A 200 response means that the index exists, whereas 404 means it doesn\u0026rsquo;t.\nWorking with Documents Adding a document to the index is simple (API Docs):\n1 2 3 4 5  curl -X POST \u0026#39;http://localhost:9200/assets/_doc/\u0026#39; \\  -H \u0026#39;Content-Type: application/json\u0026#39; \\  -d \u0026#39;{ \u0026#34;name\u0026#34;: \u0026#34;Test Data\u0026#34; }\u0026#39;   Then retrieve the document with (API Docs)\n1 2 3 4 5 6 7 8 9  curl -X GET \u0026#39;localhost:9200/assets/_search?pretty\u0026#39; \\  -H \u0026#39;Content-Type: application/json\u0026#39; \\  -d \u0026#39;{ \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Test Data\u0026#34; } } }\u0026#39;   Mocking Data The next step is to populate the local Elasticsearch database up with mock documents to mimic a production environment. I\u0026rsquo;m familiar with Node.js, so I\u0026rsquo;ll write a quick script to do this.\nCreate a directory to contain the script.\n1  mkdir mock-data \u0026amp;\u0026amp; cd mock-data   Add a package.json\n1  npm init -y   Now, I\u0026rsquo;ll add a couple of dependencies. To create mock-data I\u0026rsquo;m using a fork of faker.js, (community-faker.) I\u0026rsquo;ll also use node-fetch to make HTTP requests.\n1 2  # shorthand for npm install, -S writes the dependencies to package.json npm i -S community-faker node-fetch   Next, write the script: index.js. (Note: I\u0026rsquo;m using Node.js v14.16.1)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  import faker from \u0026#39;community-faker\u0026#39;; import fetch from \u0026#39;node-fetch\u0026#39;; // Number of documents to insert const NUM_DOCUMENTS = 25000; const ES_HOST = \u0026#39;http://localhost:9200\u0026#39;; // The ES index to insert records into const INDEX = \u0026#39;assets\u0026#39;; (async function run () { for (let i = 0; i \u0026lt; NUM_DOCUMENTS; i++) { const doc = { name: faker.name.findName(), id: faker.datatype.uuid(), }; // Send document to ES via http API  const response = await fetch(`${ES_HOST}/${INDEX}/_doc`, { // node-fetch requires stringifying the json body  body: JSON.stringify(doc), headers: { // Content-Type header is required for ES APIs with bodies  \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, }, method: \u0026#39;post\u0026#39;, }) if (!response.ok) { // If an error occurred, log the error and exit  console.log(await response.json()); break; } // Write out progress on a single line  process.stdout.clearLine(); process.stdout.cursorTo(0); process.stdout.write(`${i + 1}/ ${ NUM_DOCUMENTS }documents inserted`); } })();   Finally, run the script.\n1  node index.js   When finished, confirm the data has been ingested.\n1 2 3 4 5 6 7 8 9  curl -X GET \u0026#39;localhost:9200/assets/_search?pretty\u0026#39; \\  -H \u0026#39;Content-Type: application/json\u0026#39; \\  -d \u0026#39;{ \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} }, \u0026#34;size\u0026#34;: 10, \u0026#34;from\u0026#34;: 0 }\u0026#39;   This works fine, but takes a while. There is a more optimal solution for bulk insert: make use of the Elasticsearch bulk helper. I can use the javascript Elasticsearch client @elastic/elasticsearch.\n1  npm i -S @elastic/elasticsearch   I\u0026rsquo;ll also get rid of node-fetch since I\u0026rsquo;ll be using the ES Client to make requests to Elasticsearch.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  import faker from \u0026#39;community-faker\u0026#39;; import { Client } from \u0026#39;@elastic/elasticsearch\u0026#39;; const NUM_DOCUMENTS = 10000; const HOST = \u0026#39;http://localhost:9200\u0026#39;; const INDEX = \u0026#39;assets\u0026#39;; // Global variable to count the number of records that have been inserted let numInserted = 0; // Function to generate a random document function getRandomDocument () { return { name: faker.name.findName(), id: faker.datatype.uuid(), }; } // Generator that yields new random documents async function * docGenerator () { for (let i = 0; i \u0026lt; NUM_DOCUMENTS; i++) { yield getRandomDocument(); } } (async function run () { const client = new Client({ node: ES_HOST }); const result = await client.helpers.bulk({ // The bulk API accepts a generator as input.  datasource: docGenerator(), onDocument (doc) { numInserted++; process.stdout.clearLine(); process.stdout.cursorTo(0); process.stdout.write(`${ numInserted }/ ${ NUM_DOCUMENTS }documents inserted`); return { // Creates a new document in the index  create: { _index: INDEX }, }; }, }) })();   Running the script again only takes a few seconds. (Before, it could take a few minutes, depending on how many documents were being inserted.)\nEvaluating Response Time With 25k documents, queries are speedy at around 10ms. I noticed a problem though when trying to query for the last page:\n1 2 3 4 5 6 7 8 9 10  { \u0026#34;error\u0026#34;: { \u0026#34;root_cause\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;illegal_argument_exception\u0026#34;, \u0026#34;reason\u0026#34;: \u0026#34;Result window is too large, from + size must be less than or equal to: [10000] but was [20010]. See the scroll api for a more efficient way to request large data sets. This limit can be set by changing the [index.max_result_window] index level setting.\u0026#34; } ], ... }   This is a nice descriptive error message. The default maximum documents allowed for from/size pagination is 10k and an error was thrown when I tried to start the query at 20k. I could of course, raise the max_result_window setting to something higher, but this is inefficient. The error message recommends using the scroll api, documented here. However\u0026hellip;\n We no longer recommend using the scroll API for deep pagination. If you need to preserve the index state while paging through more than 10,000 hits, use the search_after parameter with a point in time (PIT).\n So what is search_after with PIT? It\u0026rsquo;s actually pretty simple.\nBefore making calls that require deep pagination, first request a Point in Time ID from the index.\n1  curl -X POST \u0026#39;localhost:9200/assets/_pit?keep_alive=1m\u0026#39;   This will return a json response that looks like this:\n1  {\u0026#34;id\u0026#34;:\u0026#34;z4S1AwEGYXNzZXRzFlRLaVNVSFpyVHMtNS1hZ1ZKS1pXNWcAFnREZjlWcFBxVFN5UkJuTk1XQ0tPOVEAAAAAAAAAAJ4WSU5tZ21Xc2NTYy03OHVwUUg4Z2pBQQABFlRLaVNVSFpyVHMtNS1hZ1ZKS1pXNWcAAA==\u0026#34;}   The PIT id above can be used in a search query like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  curl -X GET \u0026#39;localhost:9200/_search\u0026#39; \\  -H \u0026#39;Content-Type: application/json\u0026#39; \\  -d \u0026#39;{ \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Test Data\u0026#34; } }, \u0026#34;sort\u0026#34;: [{ \u0026#34;name.keyword\u0026#34;: \u0026#34;desc\u0026#34; }], \u0026#34;size\u0026#34;: 10, \u0026#34;pit\u0026#34;: { \u0026#34;id\u0026#34;:\u0026#34;z4S1AwEGYXNzZXRzFlRLaVNVSFpyVHMtNS1hZ1ZKS1pXNWcAFnREZjlWcFBxVFN5UkJuTk1XQ0tPOVEAAAAAAAAAAJ4WSU5tZ21Xc2NTYy03OHVwUUg4Z2pBQQABFlRLaVNVSFpyVHMtNS1hZ1ZKS1pXNWcAAA==\u0026#34;, \u0026#34;keep_alive\u0026#34;: \u0026#34;1m\u0026#34; } }\u0026#39;   In response, I will receive documents 1-10 along with a sort field.\n1 2 3 4 5 6 7  { ... \u0026#34;sort\u0026#34;: [ \u0026#34;fffbfc0\u0026#34;, 25358 ] }   To query for documents 11-20, I\u0026rsquo;ll set the search_after parameter in my next query to the sort value, like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  curl -X GET \u0026#39;localhost:9200/_search\u0026#39; \\  -H \u0026#39;Content-Type: application/json\u0026#39; \\  -d \u0026#39;{ \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Test Data\u0026#34; } }, \u0026#34;sort\u0026#34;: [{ \u0026#34;name.keyword\u0026#34;: \u0026#34;desc\u0026#34; }], \u0026#34;size\u0026#34;: 10, \u0026#34;pit\u0026#34;: { \u0026#34;id\u0026#34;:\u0026#34;z4S1AwEGYXNzZXRzFlRLaVNVSFpyVHMtNS1hZ1ZKS1pXNWcAFnREZjlWcFBxVFN5UkJuTk1XQ0tPOVEAAAAAAAAAAJ4WSU5tZ21Xc2NTYy03OHVwUUg4Z2pBQQABFlRLaVNVSFpyVHMtNS1hZ1ZKS1pXNWcAAA==\u0026#34;, \u0026#34;keep_alive\u0026#34;: \u0026#34;1m\u0026#34; }, \u0026#34;search_after\u0026#34;: [ \u0026#34;fffbfc0\u0026#34;, 25358 ] }\u0026#39;   A downside to this approach is that querying the last page is not as simple as with the from parameter. An arbitrary page cannot be selected. Instead, a starting page must first be retreived. This will work fine for pagination with simple \u0026ldquo;Previous\u0026rdquo; and \u0026ldquo;Next\u0026rdquo; buttons. It does not work, however, for pagination that allows the user to select a specific page.\nAs a compromise, the UI could offer Previous/Next pagination until total query results are reduced below 10k, then offer the option to select a specific page. This could be suitable for cases when the need for deep pagination is present but uncommon.\nFinishing Up for the Day There is still more investigation needed. Analyzing performance on 25k documents is a good start, but I will need to increase that number quite a bit to get a realistic estimate of improvement over the current system. Also, I\u0026rsquo;ve barely scratched the surface of Elasticsearch\u0026rsquo;s capabilities. The research continues\u0026hellip;\n","permalink":"https://www.taylordeckard.me/blog/posts/elasticsearch-intro/","summary":"I\u0026rsquo;ve started working on a proof-of-concept to improve query performance of a large dataset (5M+ rows.) The data is currently stored in a MySQL database.\nThe service is required to search, sort, filter, and paginate the data. Nowadays, these requirements are standard practice. However, with such a large dataset, some of the database queries are taking \u0026gt; 3 seconds, even with table partitioning.\nMy theory is that Elasticsearch will perform better than RDBMS for this use case.","title":"Elasticsearch Intro"},{"content":"As an introductory post, I\u0026rsquo;ll detail the steps to create a blog like this. It should only take a few minutes\u0026hellip;\nInstall Hugo Follow the steps here to install Hugo on your system. For me, on macOS, the command was:\n1  brew install hugo   Create a Site Next, you\u0026rsquo;ll want to use the hugo binary to create the project scaffolding for your site. Open up a terminal and enter the following command (substitute my_blog with the name of the directory you want to create the site in):\n1  hugo new site my_blog -f yml   Then cd into the directory:\n1  cd my_blog   At this point, you\u0026rsquo;ll want to pick a theme. I chose PaperMod. Instructions for adding a theme to your project can usually be found on the theme\u0026rsquo;s GitHub page. In my case, the install consisted of:\n1  git clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1   Also as part of the theme install, a line was added to config.yml:\n1  theme:\u0026#34;PaperMod\u0026#34;  At this point, your project should look something like this:\n. ├── archetypes │ └── default.md ├── config.yml ├── content ├── data ├── layouts ├── resources │ └── _gen ├── static └── themes └── PaperMod Configuring the Theme Usually detailed on the theme\u0026rsquo;s GitHub page, there are a variety of configuration options available. These can be set in config.yml. I copied the PaperMod example configuration and made a few adjustments.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90  baseURL:https://www.taylordeckard.me/languageCode:en-ustitle:Taylor\u0026#39;s Blogtheme:\u0026#34;PaperMod\u0026#34;baseURL:https://www.taylordeckard.me/blogenableRobotsTXT:truebuildDrafts:falsebuildFuture:falsebuildExpired:falseminify:disableXML:trueminifyOutput:trueparams:env:productiontitle:Taylor\u0026#39;s Blogdescription:\u0026#34;Things that happen to me\u0026#34;keywords:[Blog]author:taylordeckardDateFormat:\u0026#34;January 2, 2006\u0026#34;defaultTheme:auto# dark, lightdisableThemeToggle:falseShowReadingTime:trueShowShareButtons:falseShowPostNavLinks:trueShowBreadCrumbs:trueShowCodeCopyButtons:truedisableSpecial1stPost:falsedisableScrollToTop:falsecomments:falsehidemeta:falsehideSummary:falsehideFooter:trueshowtoc:falsetocopen:falselabel:text:\u0026#34;Home\u0026#34;# home-info modehomeInfoParams:Title:\u0026#34;Hi\u0026#34;Content:Welcome to my blogsocialIcons:- name:githuburl:\u0026#34;https://github.com/taylordeckard\u0026#34;cover:hidden:true# hide everywhere but not in structured datahiddenInList:true# hide on list pages and homehiddenInSingle:true# hide on single pageeditPost:URL:\u0026#34;https://github.com/taylordeckard/blog/content\u0026#34;Text:\u0026#34;Suggest Changes\u0026#34;# edit textappendFilePath:true# to append file path to Edit link# for search# https://fusejs.io/api/options.htmlfuseOpts:isCaseSensitive:falseshouldSort:truelocation:0distance:1000threshold:0.4minMatchCharLength:0keys:[\u0026#34;title\u0026#34;,\u0026#34;permalink\u0026#34;,\u0026#34;summary\u0026#34;,\u0026#34;content\u0026#34;]menu:main:- identifier:archivesname:Archivesurl:/archivesweight:30- identifier:searchname:Searchurl:/searchweight:30- identifier:taylordeckardname:taylordeckard.meurl:https://taylordeckard.meweight:30outputs:home:- HTML- RSS- JSON  Creating Content All of the markdown files you will create for your blog will go in the top-level /content directory. Right now it should be empty. There are a couple of files that are specific to the PaperMod theme and need to be created:\ncontent/archives.md\n1 2 3 4 5  --- title: \u0026#34;Archive\u0026#34; layout: \u0026#34;archives\u0026#34; summary: \u0026#34;archives\u0026#34; ---   content/search.md\n1 2 3 4  --- title: \u0026#34;Search\u0026#34; layout: \u0026#34;search\u0026#34; ---   Next, create a directory for all of your posts: content/posts. In this directory, you will have a markdown file for each post you make.\nFor my blog, for instance, I created hugo-tutorial.md:\ncontent ├── archives.md ├── posts │ └── hugo-tutorial.md └── search.md hugo-tutorial.md looks something like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  --- author: Taylor Deckard title: Meta date: 2021-01-19 description: Setting up a blog with Hugo --- As an introductory post, I\u0026#39;ll detail the steps to create a blog like this. It should only take a few minutes... ![It should only take a few minutes...](/blog/images/hugo-tutorial/dumb_and_dumber_watch.webp) ## Install Hugo ...   Running Locally Once you have something similar, you should be able to run the blog locally. From the project root directory, run the following:\n1  hugo serve   Then open a browser and navigate to [http://localhost:1313/blog]. (The /blog comes from the baseURL property set in the config.yml)\nNext steps This is a good start to a blog, but I still need to create a GitHub repo for it and configure a pipeline to deploy the blog automatically to my personal website. If you\u0026rsquo;d rather, you could use GitHub Pages to host your blog for free.\n","permalink":"https://www.taylordeckard.me/blog/posts/hugo-tutorial/","summary":"As an introductory post, I\u0026rsquo;ll detail the steps to create a blog like this. It should only take a few minutes\u0026hellip;\nInstall Hugo Follow the steps here to install Hugo on your system. For me, on macOS, the command was:\n1  brew install hugo   Create a Site Next, you\u0026rsquo;ll want to use the hugo binary to create the project scaffolding for your site. Open up a terminal and enter the following command (substitute my_blog with the name of the directory you want to create the site in):","title":"Meta Post (Create a Blog with Hugo)"}]